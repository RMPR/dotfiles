**** BEGIN LOGGING AT Tue Mar 23 17:22:20 2021

Mar 23 17:22:20 *	Now talking on ##C
Mar 23 17:22:20 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 17:22:20 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 17:22:20 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 17:22:20 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 18:28:12 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 23 18:28:12 2021

**** BEGIN LOGGING AT Tue Mar 23 18:32:23 2021

Mar 23 18:32:23 *	Now talking on ##C
Mar 23 18:32:23 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 18:32:23 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 18:32:23 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 18:32:23 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 18:33:12 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 23 18:33:12 2021

**** BEGIN LOGGING AT Tue Mar 23 18:34:35 2021

Mar 23 18:34:35 *	Now talking on ##C
Mar 23 18:34:35 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 18:34:35 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 18:34:36 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 18:34:36 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 18:36:42 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 23 18:36:42 2021

**** BEGIN LOGGING AT Tue Mar 23 18:39:54 2021

Mar 23 18:39:54 *	Now talking on ##C
Mar 23 18:39:54 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 18:39:54 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 18:39:55 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 18:39:55 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 18:57:32 *	cousteau_ is now known as cousteau
Mar 23 18:59:42 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 23 18:59:42 2021

**** BEGIN LOGGING AT Tue Mar 23 19:03:43 2021

Mar 23 19:03:43 *	Now talking on ##C
Mar 23 19:03:43 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 19:03:43 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 19:03:44 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 19:03:44 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 19:18:39 <moon-child>	is there a good reason why a trailing array member can't have incomplete type
Mar 23 19:18:42 <moon-child>	?
Mar 23 19:19:28 <atk>	you mean the flexible array member?
Mar 23 19:19:44 <moon-child>	yeah
Mar 23 19:20:02 <atk>	yes, it can't have an incomplete type because it's a struct field, how is the array indexing going to work on an incomplete type? How will the compiler know how to align it?
Mar 23 19:21:36 <moon-child>	well, obviously you would need to define the type before accessing any instances thereof
Mar 23 19:21:43 <moon-child>	but there shouldn't be any harm in just defining the type
Mar 23 19:29:31 <twkm>	compile-time vs run-time.  types don't change at run-time.
Mar 23 19:31:20 <moon-child>	twkm: funny that, technically ub (but not in any way that matters), I like to redefine the same type distinctly in different translation units
Mar 23 19:33:15 <atk>	moon-child: so you're advocating that using an incomplete type inside a struct should be allowed making the whole struct incomplete
Mar 23 19:33:22 <atk>	I mean, this would work I guess..
Mar 23 19:33:39 <atk>	the problem is, when is this useful?
Mar 23 19:34:00 <atk>	in the cases where it would be useful to me it seems like you could forego filling the struct entirely and just leave it entirely incomplete
Mar 23 19:34:06 <twkm>	(of course a struct with a fam is incomplete)
Mar 23 19:34:11 <atk>	Not sure where a partially complete struct would be useful
Mar 23 19:34:47 <moon-child>	atk: I have a nice oop pattern that relies on it.  It currently needs an extra indirection; this way, it wouldn't need that
Mar 23 19:34:55 <moon-child>	I have a usenet post somewhere describing it; one sec
Mar 23 19:35:32 <atk>	If it's an OOP pattern in C of all places it seems likely more work than it's worth.
Mar 23 19:37:05 <moon-child>	why?
Mar 23 19:37:07 <moon-child>	https://comp.lang.c.narkive.com/aa5pZoND/polymorphic-oop-hack
Mar 23 19:38:11 <atk>	C does not lend itself to writing OOP code and OOP in general is oversold as a solution to problems it is not optimal at solving which makes me think that it's likely far more likely that you can avoid all the extra work and still solve your problems well if you don't try to emulate an OOP in C in the majority of cases
Mar 23 19:38:33 <atk>	but it also depend on what you mean by OOP and "a sprinkling of Polymorphism" is not it.
Mar 23 19:39:12 <moon-child>	I think the term is somewhat poorly defined.  Let it be a sprinkling of polymorphism, sure.  Certainly I think gobject is horrifying
Mar 23 19:41:14 <atk>	hmm, this doesn't add THAT much type safety but for C this is an interesting thing nevertheless
Mar 23 19:41:37 <atk>	But personally I would never want to write UI code in C
Mar 23 19:41:48 <moon-child>	I gave up on the ui lib
Mar 23 19:42:01 <moon-child>	(not because I don't want to write ui code in c, but because widget toolkits are a dead end)
Mar 23 19:42:09 <moon-child>	working on my audio lib now
Mar 23 19:42:18 <atk>	Easier to use a higher level language (e.g. Lua) and just interact with a C library
Mar 23 19:43:00 <moon-child>	yeah
Mar 23 19:43:22 <moon-child>	or even write the whole thing in lisp; some pretty high-perf impls nowadays
Mar 23 19:54:35 <hecanjog>	moon-child: is there somewhere I can learn more about your audio lib project? just curious!
Mar 23 19:54:44 <moon-child>	github.com/moon-chilled/gorilla-audio
Mar 23 19:54:49 <hecanjog>	thanks!
Mar 23 20:23:42 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 23 20:23:42 2021

**** BEGIN LOGGING AT Tue Mar 23 20:27:43 2021

Mar 23 20:27:43 *	Now talking on ##C
Mar 23 20:27:43 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 23 20:27:43 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 23 20:27:43 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 23 20:27:43 *	Channel ##c url: http://www.iso-9899.info/
Mar 23 20:41:05 *	KindTwo is now known as KindOne
Mar 23 21:15:02 <Gustavo6046>	stdio.h is AWESOME!
Mar 23 21:26:48 *	towel_ is now known as towel
Mar 23 22:06:38 <kkd>	lol
Mar 23 22:20:10 <fstd>	isn't the H programming language off-topic here?
Mar 24 00:06:42 *	Disconnected ()
**** ENDING LOGGING AT Wed Mar 24 00:06:42 2021

**** BEGIN LOGGING AT Wed Mar 24 08:38:10 2021

Mar 24 08:38:10 *	Now talking on ##C
Mar 24 08:38:10 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 24 08:38:10 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 24 08:38:10 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 24 08:38:10 *	Channel ##c url: http://www.iso-9899.info/
Mar 24 08:38:45 <mihael>	caze: I did, it was way cleaner. Gave me something to search about as well. :)
Mar 24 08:43:35 <caze>	mihael: As I said, an array is not necessary.
Mar 24 08:49:29 *	Guest44763 is now known as vt
Mar 24 08:53:03 <caze>	mihael: Are you familiar with recursion?
Mar 24 10:11:15 <kurahaupo>	caze: there are 10 kinds of people in the world: those who count in binary, and those who don't. I count in ternary. Or sometimes quaternary.
Mar 24 10:20:57 <naquad>	hi
Mar 24 10:21:22 <naquad>	is it ok to inline typedef and named struct definition: typedef struct xyz_s {int a;} xyz_t; ?
Mar 24 10:21:39 <naquad>	it compiles and works with -std=c89, but i'm not sure if that's a good idea
Mar 24 10:23:11 <[smlckz]>	if you want to save space and time, fine; who want's to write`struct` again and again
Mar 24 10:23:56 <baltazar>	(( again this brings up the old issue of *_t being reserved by posix or something ))
Mar 24 10:24:37 <[smlckz]>	oh, I missed that baltazar hah!
Mar 24 10:25:01 <baltazar>	so stupid tbh
Mar 24 10:25:59 <[smlckz]>	as well as everything starting with `_`
Mar 24 10:27:16 <dave0>	naquad: yep, that's no problem
Mar 24 10:33:32 <naquad>	got it, thank you for help guys
Mar 24 11:33:41 <JohnnyVM>	hi, one question, i am seeng that for check truncating values of snprintf its something like if(bufsize >= snprintf(buf, bufsize, etc)) { error}
Mar 24 11:33:41 <JohnnyVM>	but the return value of snprintf add the '\0' to the count, then for example snprintf(buff[5], 5, "home") ==5 <- this is correct but raise error if tested
Mar 24 11:33:41 <JohnnyVM>	how i can test for truncated string ?
Mar 24 11:36:57 <slidercrank>	what's a truncated string? when its size is greater than your buffer? or when it's lower than the buffer size?
Mar 24 11:37:53 <slidercrank>	anyway, knowing the number of successfully written bytes, the size of your buffer and that a string must terminate with \0, you can check all kinds of situations
Mar 24 11:39:28 <dave0>	JohnnyVM: i gotta look up the man page
Mar 24 11:40:25 <dave0>	JohnnyVM: you can get the actual size that would be written with   int actual_size = snprintf(NULL, 0, "format", args, args, args);
Mar 24 11:41:45 <baltazar>	> a return value of size or more means that the output was truncated.
Mar 24 11:42:18 <dave0>	yep. from the man page: "Upon successful completion, the snprintf() function shall return the number of bytes that would be written to s had n been sufficiently large excluding the terminating null byte"
Mar 24 11:43:46 <dave0>	int n = snprintf(buf, size, "format", args, args); if(n < 0 || n >= size) { ... error ... }
Mar 24 11:44:12 <JohnnyVM>	dave0 if size its 7 in yor case return error
Mar 24 11:44:24 <dave0>	yeah my check isn't very good
Mar 24 11:44:42 <dave0>	if(n < 0) { ... some error .. } if(n >= size) { ... was truncated .. }
Mar 24 11:44:52 <JohnnyVM>	same
Mar 24 11:45:03 <JohnnyVM>	size = 7 return error
Mar 24 11:46:46 <slidercrank>	    int nr;
Mar 24 11:46:46 <slidercrank>	    char buf[10];
Mar 24 11:46:47 <slidercrank>	    nr = snprintf(buf, sizeof(buf), "01234567890abcdefg");
Mar 24 11:46:47 <slidercrank>	    if ((nr > 0 ) && (buf[nr] == '\0'))
Mar 24 11:46:47 <slidercrank>	<------>printf("truncated\n");
Mar 24 11:46:47 *	ChanServ gives channel operator status to candide
Mar 24 11:46:48 *	candide sets ban on *!~slidercra@ircpuzzles/2015/april-fools/fifth/slidercrank
Mar 24 11:47:35 <JohnnyVM>	slidercrank if the input string is 012345678 will fail
Mar 24 11:47:42 <dave0>	no that's bad, because nr could be > sizeof(buf)
Mar 24 11:47:46 <JohnnyVM>	but the output its not truncated
Mar 24 11:47:54 *	candide removes ban on *!~slidercra@ircpuzzles/2015/april-fools/fifth/slidercrank
Mar 24 11:48:06 <dave0>	nr is the amount of characters that WOULD have been written, not how many were actuall written
Mar 24 11:48:32 <slidercrank>	dave0, who said that nr could be > sizeof(buf)?
Mar 24 11:48:42 <JohnnyVM>	the man apges of snprintf
Mar 24 11:48:43 <dave0>	man page: "Upon successful completion, the snprintf() function shall return the number of bytes that would be written to s had n been sufficiently large excluding the terminating null byte"
Mar 24 11:49:56 <JohnnyVM>	my only idea its check against strlen
Mar 24 11:50:18 <JohnnyVM>	if i >= buff_size && i != strlen(buff)
Mar 24 11:50:31 <dave0>	JohnnyVM: baltazar already gave the correct test
Mar 24 11:50:54 <JohnnyVM>	ok, without =, only >
Mar 24 11:51:08 <JohnnyVM>	ty guys, the most of internet are incorrect XD
Mar 24 11:52:25 <dave0>	JohnnyVM: char buf[100]; int size = sizeof(buf); int n = snprintf(buf, size, "format", args, args); if(n < 0) { perror("snprintf error"); } if(n >= size) { ... output was truncated .. }
Mar 24 11:53:12 <dave0>	they are cheap tests
Mar 24 11:54:07 <nitrix>	Depending on the known invariants, they could also be turned into asserts to be even cheaper.
Mar 24 11:56:15 <JohnnyVM>	codepad dont work
Mar 24 11:56:18 <JohnnyVM>	:(
Mar 24 11:56:34 <JohnnyVM>	    int i = snprintf(buff, 2, "aa");
Mar 24 11:56:34 <JohnnyVM>	    if(i > 2){ printf("Print should be printed");}
Mar 24 11:56:54 <dave0>	use >=
Mar 24 11:57:09 <JohnnyVM>	    i = snprintf(buff, 2, "a");
Mar 24 11:57:09 <JohnnyVM>	    if(i >= 2){ printf("Print shouldn't be printed");}
Mar 24 11:57:15 <JohnnyVM>	this will fail
Mar 24 11:57:30 <JohnnyVM>	cahr buff [2];
Mar 24 11:57:35 <dave0>	in the first case, i==2   in the second case, i==1
Mar 24 11:57:42 <JohnnyVM>	    charbuff[2]; int i = snprintf(buff, 2, "a");
Mar 24 11:57:43 <JohnnyVM>	    if(i >= 2){ printf("Print shouldn't be printed");}
Mar 24 11:57:53 <dave0>	in that case i==1
Mar 24 11:59:06 <JohnnyVM>	fuck
Mar 24 11:59:09 <dave0>	maybe you should do    char buff[2]; int i = snprintf(buff, 2, "a"); printf("i==%d\n", i);
Mar 24 11:59:32 <JohnnyVM>	the manpages in rhel 8 said "including the '\0'"
Mar 24 11:59:43 <JohnnyVM>	i said in internet excluding
Mar 24 11:59:58 <dave0>	ah what's worse than no documentation? wrong documentation :-)
Mar 24 12:00:13 <JohnnyVM>	man pages in internet -> excluding man pages in my system -> including '\0'
Mar 24 12:00:29 <dave0>	i stick to posix man pages: https://pubs.opengroup.org/onlinepubs/9699919799/idx/functions.html
Mar 24 12:00:30 <candide>	Title of dave0's link: System Interfaces
Mar 24 12:00:33 <JohnnyVM>	yes, but in my system work including the '\0'
Mar 24 12:01:08 <JohnnyVM>	now i need know what happened with snprintf in rhel8 to be broken
Mar 24 12:02:11 <JohnnyVM>	ok
Mar 24 12:02:15 <JohnnyVM>	no, i was worng
Mar 24 12:02:18 <JohnnyVM>	work fine
Mar 24 12:02:23 <JohnnyVM>	ok, ty guys
Mar 24 12:02:38 <JohnnyVM>	fuck documentation
Mar 24 12:58:17 <amosbird>	Hello, how can I check if a environment var is not empty in c?
Mar 24 12:59:03 <fizzie>	,c11 7.22.4.6
Mar 24 12:59:06 <candide>	http://www.iso-9899.info/n1570.html#7.22.4.6 [The getenv function] 1 #include <stdlib.h> char *getenv(const char *name); Description 2 The getenv function searches an environment list , provided by the host environment, for a string that matches the string pointed to by name. The set of environment names and the method for altering the environment list ... [truncated; see https://0x0.st/-q_V.c for full text.]
Mar 24 13:00:25 <fizzie>	("If the specified `name` cannot be found, a null pointer is required.")
Mar 24 14:30:23 <Thedarkb>	,cc x=sizeof(*(void*)1);
Mar 24 14:30:24 <candide>	Thedarkb: error: 'x' undeclared
Mar 24 14:30:33 <Thedarkb>	,cc int x=sizeof(*(void*)1);
Mar 24 14:30:35 <candide>	Thedarkb: [warning: invalid application of 'sizeof' to a void type [-Wpointer-arith]] no output: x = 1
Mar 24 14:50:23 <kplant>	that looks like a nasty gnu extension
Mar 24 14:50:31 <kplant>	,cc printf("%zu\n", sizeof(void));
Mar 24 14:50:33 <candide>	kplant: [warning: invalid application of 'sizeof' to a void type [-Wpointer-arith]] 1
Mar 24 18:35:18 *	Disconnected ()
**** ENDING LOGGING AT Wed Mar 24 18:35:18 2021

**** BEGIN LOGGING AT Wed Mar 24 18:35:44 2021

Mar 24 18:35:44 *	Now talking on ##C
Mar 24 18:35:44 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 24 18:35:44 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 24 18:35:45 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 24 18:35:45 *	Channel ##c url: http://www.iso-9899.info/
Mar 24 18:35:47 <lemonade`>	wroathe: yes, it is. I wasn't sure how familiar he or she was with the concept
Mar 24 18:37:09 <wroathe>	nvmd: The benefit of defining a higher order function to wrap this and perform the check is that it can remove some conditionals from the user's code
Mar 24 18:37:12 <fizzie>	cadmio: Regarding CTRL_KEY and ASCII, the way that specific character set is designed, character values 0 .. 0x1f are control characters, and they're conventionally referred to using non-control characters in the "same position", so that "ctrl-q" (0x71) denotes the control character DC1 (0x11).
Mar 24 18:37:22 <fizzie>	cadmio: As for ^q not quitting, `enableRawMode()` sounds like a misnamed function, because just disabling the ECHO flag doesn't make the terminal any more "raw" in the raw-vs.-cooked sense. So ^q is probably being still interpreted using its usual flow-control semantics.
Mar 24 18:37:33 <wroathe>	nvmd: At the expense of having to operate through these feature test wrappers
Mar 24 18:37:40 <cadmio>	fizzie: thanks, I solved that
Mar 24 18:37:55 <wroathe>	nvmd: But rather than using stdarg this could easily just be a function-like macro with variadic args
Mar 24 18:38:14 <fizzie>	I don't think C is the right language for that sort of metaprogramming.
Mar 24 18:38:33 <wroathe>	fizzie: Probably not. I'm just spitballing here.
Mar 24 18:39:23 <wroathe>	fizzie: The "ugly" part of dealing with this is the conditionals that the user will have to write to determine if the feature is enabled or not
Mar 24 18:40:00 <wroathe>	fizzie: Or where you talking to cadmio? :P
Mar 24 18:40:04 <wroathe>	were*
Mar 24 18:41:06 <nvmd>	if it's to me, fizzie's right. It's a pick your poison type situation.
Mar 24 18:43:42 <nvmd>	Granularity isn't a concern, though. I'm just looking for a way to define a single macro that disables or enables an entire component, not multiple macros that each do so to a part of the component
Mar 24 18:44:19 <wroathe>	nvmd: https://godbolt.org/z/ncqjsn6hE
Mar 24 18:44:21 <nvmd>	and it's done the most implicit manner
Mar 24 18:44:29 <wroathe>	nvmd: This is kind of in the spirit of what I was thinking
Mar 24 18:44:53 <nvmd>	Yeah, I figured as much.
Mar 24 18:45:06 <lemonade`>	cc -DMYCOMPONENT=1 file.c
Mar 24 18:46:58 <fizzie>	Honestly I'd prefer "naked" conditionals over macros where you pass blocks as parameters, but I guess that's a matter of æsthetics.
Mar 24 18:47:53 <wroathe>	Well, that's just like, your opinion, man
Mar 24 18:47:53 <fizzie>	I guess sometimes the interface is such that you could just go with the "compile in (handwritten) stubs" thing.
Mar 24 18:48:30 <fizzie>	Where you just have your build system replace the `foo` directory with a `foo_noop` one, that implements the interface but does nothing.
Mar 24 18:49:23 <nvmd>	so many ideas....
Mar 24 18:49:35 <wroathe>	I suspect that would really only apply if your interface was made up of functions that don't return anything
Mar 24 18:50:37 <wroathe>	Because otherwise the user will have to check the feature flag anyway before using them, and if they have to check the feature flag there's not much point in creating the stubs
Mar 24 18:52:32 <fizzie>	By "the interface is such" I meant it contained functions where there are reasonable return values in the noop case. But it really depends what the component is all about.
Mar 24 18:52:42 <wroathe>	Yup
Mar 24 18:52:54 <fizzie>	E.g. in the logging case, I imagine it's perfectly feasible.
Mar 24 18:53:05 <wroathe>	Totally
Mar 24 18:56:37 <nvmd>	Seems to me this is mainly constrained by whether the function returns something. Is that right?
Mar 24 18:57:32 <nvmd>	trying to mentally categorize the examples for learning and future reference related a recent issue I had. They're all valid.
Mar 24 18:58:30 <fizzie>	I think it's a little more abstract than that. Maybe more like, whether there's only one reasonable way to behave in the case the component is absent, no matter what the context it is the component is being used in.
Mar 24 18:59:02 <nvmd>	hmm, that makes sense.
Mar 24 18:59:32 <fizzie>	E.g., a logging component tends to have a function that does return something (a bool), that can be used to test if a specific logging *level* is enabled, but that's not a problem because the no-logging stubs can just say "no it isn't" for all levels.
Mar 24 18:59:45 <lemonade`>	I would start by considering what you want the calling code to do in the case where the component is activated, and the case in which it's not activated. then figure out a way to combine those two.
Mar 24 19:00:16 <nvmd>	yeah, that seems to be the way
Mar 24 19:00:52 <nvmd>	I think I got it, at least the notion of the approaches
Mar 24 19:01:09 <wroathe>	Well, the log level example is a little interesting because that in itself is a form of feature flag. It's akin to shipping a function with the signature bool logging_enabled();
Mar 24 19:02:29 <wroathe>	i.e. the calling code is explicitly trying to determine whether or not the "error logging" feature is enabled
Mar 24 19:04:32 <nvmd>	Another question I have is about patterns that deal with software configurations, especially regarding how they should be structured.
Mar 24 19:05:09 *	Silvard_ is now known as Silvard
Mar 24 19:05:17 <nvmd>	The way I'm currently doing is having a global struct that has some shitty defined hierarchy of settings
Mar 24 19:06:57 <nvmd>	something along the lines of 'external struct gCfg; ... set_ip(gCfg.net.ip); set_gw(gCfg.net.gw);'
Mar 24 19:08:58 <nvmd>	there's no particular reason for the hierarchy, though it seems a little bit inuitive to have it (ip under net struct, etc).
Mar 24 19:09:05 <nvmd>	but how would you guys do it?
Mar 24 19:09:39 <nvmd>	in a way that's easier to add or remove more settings?
Mar 24 19:10:06 <twkm>	as an aside, a "global" needs special handling if you want recursion, multiple whatever's, or there are threads involved.
Mar 24 19:11:09 <wroathe>	nvmd: Well, if the settings are grouped into struct members solely for organizational reasons I might consider just flattening things.
Mar 24 19:11:30 <nvmd>	twkm: yeah, that's why I want to change it.
Mar 24 19:12:42 <nvmd>	wroathe: yeah, that's a start.
Mar 24 19:13:37 <fizzie>	wroathe: FWIW, in the logging framework I was thinking of, that function is provided for the rare case of "there's something semi-expensive I want to do only if logging is enabled", with the majority of calls not needing to check it explicitly.
Mar 24 19:14:41 <fizzie>	I use protos for all configuration, which naturally ends up as a hierarchy (esp. if there's some message definitions to share), but that's just my bias showing up.
Mar 24 19:14:44 <wroathe>	fizzie: Yeah. I agree it's more nuanced than it just being about return value, but it seems like a good enough approximation of the problem to me.
Mar 24 19:14:58 <wroathe>	protos?
Mar 24 19:15:04 <nvmd>	I was looking for something along the lines of how git or systemd solve this issue, but I'm still noob to dive into the code and understand how they do it
Mar 24 19:15:16 <fizzie>	You know, protocol buffers. That Google thing.
Mar 24 19:15:26 <wroathe>	Oh, right
Mar 24 19:15:48 <wroathe>	I didn't realize protocol buffers were a tool for modeling general program configuration data
Mar 24 19:16:47 <fizzie>	When all you've got is a hammer...
Mar 24 19:17:05 <wroathe>	Hahaha. Protocol buffer all the things.
Mar 24 19:17:05 <nvmd>	isn't protobuff for when you want to move stuff around, kinda like a json replacement?
Mar 24 19:17:07 <fizzie>	I mostly just like the textproto syntax more than your YAMLs or TOMLs or JSONs or whatnot.
Mar 24 19:17:24 <nvmd>	Ideally, I'd decode the protobuff and have an internal representation I can use
Mar 24 19:17:46 <fizzie>	Yeah, that's the "pure" approach.
Mar 24 19:17:57 <nvmd>	the way to structure this internal representation is what I'm after
Mar 24 19:18:09 <wroathe>	fizzie: So your programs read their configuration from the network then?
Mar 24 19:18:18 <fizzie>	Anyway, you do need to "move" configuration (read it from file, push it to a server, and so on) data too.
Mar 24 19:18:30 <fizzie>	wroathe: My personal programs just read it from a file.
Mar 24 19:18:38 <wroathe>	How does that work when you want command line arguments, file-based configuration, or environment variables? Do you just handle them separately?
Mar 24 19:19:53 <wroathe>	Hmm, I always thought of protobufs as a network-only thing. Interesting. Do you have a link on hand to an example of one of these configuration files?
Mar 24 19:21:19 <nvmd>	protobuf generates source code representing the structure you specified on your proto files
Mar 24 19:21:49 <wroathe>	Oh, so it's about defining the types with proto files then
Mar 24 19:21:52 <nvmd>	so I think fizzie means just use the structure you used on your protobuf structure
Mar 24 19:22:03 <wroathe>	Rather than in C code itself
Mar 24 19:22:14 <nvmd>	yes
Mar 24 19:23:00 <nvmd>	never used it, though. Just read a bit about it when studying serialization.
Mar 24 19:23:48 <nvmd>	also never did figure which is better for embedded: protobuf or flatbuffers
Mar 24 19:23:56 <fizzie>	wroathe: Yes. I mean, I tend to do it the lazy way and just use the proto-generated types to hold the configuration in the program as well, which doesn't necessarily scale, but for small things it's fine.
Mar 24 19:24:34 <nvmd>	so we're kind of on the same boat, fizzie, wrt to scalability
Mar 24 19:24:55 <nvmd>	which is also part of the problem in my case.
Mar 24 19:25:04 <fizzie>	wroathe: I haven't really gotten around to publish anything in the last few years, so I don't have a great example handy. But here's how a bot we have for esolangs.org is configured: https://github.com/fis/esolangs/blob/master/esobot/config.proto -> https://github.com/fis/bracket/blob/master/irc/config.proto
Mar 24 19:25:08 *	lukedashjr is now known as luke-jr
Mar 24 19:27:37 <fizzie>	And https://0x0.st/-qf-.txt is what config.textpb looks like, slightly redacted.
Mar 24 19:29:21 <wroathe>	I didn't realize you had to explicitly enumerate the fields like that with protobuf definitions
Mar 24 19:29:31 <wroathe>	Either way, neat
Mar 24 19:36:33 <fizzie>	It's not all that perfect, of course. There's some problems with using the protos directly in the code (which is why it's a little against protobuf best practices), and also limits as to how complex you can make the configuration when it's just a textproto file -- which is why people keep coming up with things like https://jsonnet.org/ or our internal thing-that-shall-not-be-named.
Mar 24 19:36:35 <candide>	Title of fizzie's link: Jsonnet - The Data Templating Language
Mar 24 19:38:37 <wroathe>	Haha, I can only imagine what kind of black magic Google uses internally for pretty much everything. I wouldn't be surprised if the entire SDLC is managed by internal-only proprietary software.
Mar 24 19:58:04 <veltas>	wroathe: You don't have to imagine there are thousands of engineers at google and they like talking about their internal setup
Mar 24 20:04:28 <wroathe>	veltas: And yet fizzie is leaving us hanging on the thing-that-shall-not-be-named
Mar 24 20:04:42 <wroathe>	veltas: What if we've got thousands of fizzies on our hands
Mar 24 20:11:57 <fizzie>	wroathe: Here's one of those thousands making references to the thing-that-shall-not-be-named in a thread about Jsonnet: https://news.ycombinator.com/item?id=19657866
Mar 24 20:11:58 <candide>	Title of fizzie's link: Finally a public version of GCL/Borgcfg :-) For people who doesn't know, GCL (G... | Hacker News
Mar 24 20:13:00 <fizzie>	"-- under what circumstances would configurations become complex enough to where this becomes necessary?" Oh, if only they didn't.
Mar 24 20:18:40 <fizzie>	wrobinso1: FWIW on the development front, a bunch of our internal tools are now external as well (Blaze & Kythe come to mind first; and of course everything Cloud), leaving even less scope for you to imagine something wonderful just to be disappointed by the reality.
Mar 24 20:32:10 <oldlaptop>	fizzie: conversely the old Google Code now appears to be internal, from what I can tell from the outside
Mar 24 20:32:29 <oldlaptop>	or is it only chromium/chromiumos that uses it?
Mar 24 20:35:22 <fizzie>	I think it's pretty much just Chrome and Android that's still on it, because they're too big to fail^W move, or something. I've no idea of the details, I'm just going by https://opensource.googleblog.com/2015/03/farewell-to-google-code.html
Mar 24 21:03:19 <xace>	what is the thing-that-shall-not-be-named?
Mar 24 21:14:31 <Kerberos88>	If I can't use rewind(stdin); how can I save the stdin?
Mar 24 21:14:41 <Kerberos88>	if I want to iterate it more than once
Mar 24 21:16:32 <veltas>	Kerberos88: You can't use rewind() or fsetpos() on all files, for files where fsetpos() fails you would have to read the whole file to e.g. a temporary file, or memory.
Mar 24 21:16:42 <veltas>	If you wanted to iterate twice and actually needed to
Mar 24 21:18:09 <Kerberos88>	Yeah, I figured. Took me a while to realise why it wasn't working (I wanted to use input from a file)
Mar 24 21:18:16 <veltas>	You should generally avoid rewind() since it's equivalent to fseek(stream, 0, SEEK_SET) without any error info
Mar 24 21:18:49 <Kerberos88>	pipe*
Mar 24 21:19:13 <Kerberos88>	how would I go about saving pipe input into a memory buffer? Do I just initialize an array and fill with fgets?
Mar 24 21:19:35 <Kerberos88>	Is there something I need to know about doing that
Mar 24 21:46:06 <twkm>	Kerberos88: provided text was written to the pipe, yes that's the gist of it.
Mar 24 21:47:03 <twkm>	you can also use getchar or fread.  it depends more as to how you will process the data.
Mar 24 22:16:13 <Gustavo6046>	I never understand people who write an entire commented-out essay justifying their indifference to a small memory leak, versus simply typingfree().
Mar 24 22:16:19 <Gustavo6046>	typing free() *
**** ENDING LOGGING AT Wed Mar 24 22:53:10 2021

**** BEGIN LOGGING AT Fri Mar 26 23:08:29 2021

Mar 26 23:08:29 *	Now talking on ##C
Mar 26 23:08:29 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 26 23:08:29 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 26 23:08:29 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 26 23:08:29 *	Channel ##c url: http://www.iso-9899.info/
Mar 26 23:14:32 <henistein>	in what situations should i use int8_t, int16_t and int32_t?
Mar 26 23:15:01 <henistein>	or can I always use int with no problems?
Mar 26 23:15:07 <LiaoTao>	When you want to have signed integers of a fixed width
Mar 26 23:16:28 <henistein>	Exactly, why should I want a fixed 32 width int, in low level SO programming per example?
Mar 26 23:17:09 <LiaoTao>	It is good practice to use fixed integer widths for things like file formats and network protocols. The size of e.g. int is implementation defined
Mar 26 23:17:40 <LiaoTao>	It is also used for memory usage optimization where you know that you only have to store an 8-bit integer
Mar 26 23:18:17 <henistein>	oh ok I unserstand, so just in speciefic situations
Mar 26 23:19:21 <twkm>	i disagree with most of that.
Mar 26 23:22:54 <henistein>	what is your opinion twkm?
Mar 26 23:23:33 <twkm>	file and network formats do tend to demand fixed representations but that's a matter for (de)serialization not the types your program uses.  also you might consider that the www shows that entirely textual, sematic boundaried fields are quite workable.
Mar 26 23:23:49 <remal>	Hello, any recommendations for compiler engineering books?
Mar 26 23:30:52 <NoXzema>	Asking in both ##c++ and ##c is bound to irritate some
Mar 26 23:31:17 <remal>	...whops
Mar 26 23:34:47 <twkm>	ignoring topics can too.
Mar 26 23:35:23 <remal>	Loosely topical.
Mar 26 23:37:33 <twkm>	yet the books part of our wiki mentions at least one.
Mar 26 23:39:40 <remal>	my bad.
Mar 27 00:07:10 *	Disconnected ()
**** ENDING LOGGING AT Sat Mar 27 00:07:10 2021

**** BEGIN LOGGING AT Sat Mar 27 09:29:09 2021

Mar 27 09:29:09 *	Now talking on ##C
Mar 27 09:29:09 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 27 09:29:09 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 27 09:29:09 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 27 09:29:09 *	Channel ##c url: http://www.iso-9899.info/
Mar 27 09:43:31 <user51>	if i have two structs of the same type, what's the difference between memmove(&a,&b, n); and a = b?
Mar 27 10:07:21 <remal>	Hello, I'm new to malloc. I'm I allowed to allocate like so?
Mar 27 10:07:30 <remal>	  while ((opt = getopt(argc, argv, ":f:d:h")) != -1) {
Mar 27 10:07:30 <remal>	    switch (opt) {
Mar 27 10:07:30 <remal>	    case 'd':
Mar 27 10:07:30 <remal>	      printf("[date] %s\n", optarg);
Mar 27 10:07:30 <remal>	      break;
Mar 27 10:07:30 *	ChanServ gives channel operator status to candide
Mar 27 10:07:32 <remal>	    case 'f':
Mar 27 10:07:32 *	candide sets ban on *!~remal@*.cgocable.net
Mar 27 10:07:53 <julianmarcos>	remal: Dont paste the text use codepad.org
Mar 27 10:08:35 *	candide removes ban on *!~remal@*.cgocable.net
Mar 27 10:08:37 <remal>	oh shit
Mar 27 10:08:40 <remal>	https://bpa.st/OT2Q
Mar 27 10:08:42 <remal>	sry
Mar 27 10:08:45 <remal>	yeah, mistake
Mar 27 10:08:45 *	candide sets ban on *!~remal@*.cgocable.net
Mar 27 10:10:52 <julianmarcos>	And use only one message not like "oh ****\n$url\nsry\nyeah, mistake", that is spam
Mar 27 10:13:53 *	candide removes ban on *!~remal@*.cgocable.net
Mar 27 10:15:31 <julianmarcos>	candide: Is that ban a mute ban?, or is it just by some mode set on the chan?
Mar 27 10:15:32 <candide>	j​ulianmarcos, A​s if!
Mar 27 10:24:40 <Xgc>	remal: Not really.  You didn't provide enough detail and you didn't appear to check for malloc errors.  Better to create a self-contained test case of the malloc use you're trying to show.
Mar 27 10:25:27 <remal>	Yeah, I just realized what I was doing was unnecessary anyway. Thanks Xgc
Mar 27 10:25:54 <Xgc>	remal: Also, those casts are probably a bad idea.
Mar 27 10:26:38 <remal>	https://bpa.st/ULGA
Mar 27 10:26:42 <remal>	I have this though
Mar 27 10:26:48 <remal>	how can I get away without casting?
Mar 27 10:27:17 <Xgc>	remal: That's not valid C, at least based on the information in that paste.
Mar 27 10:27:36 <remal>	weird, it compiled
Mar 27 10:27:40 <Xgc>	remal: struct node doesn't exist / is not declared.
Mar 27 10:27:55 <Xgc>	remal: Again, you probably didn't provide all the detail.
Mar 27 10:28:24 <remal>	alright, give me a second
Mar 27 10:28:26 <Xgc>	remal: You have a typedef just fine, but not based on a tagged structure with the name node.
Mar 27 10:29:08 <Xgc>	remal: typedef struct node { ... would have been ok.
Mar 27 10:29:39 <remal>	Oh, this makes sense
Mar 27 10:29:54 <caze>	remal: What data structure are you making?
Mar 27 10:30:10 <remal>	a linked list, lol
Mar 27 10:30:16 <caze>	What kind?
Mar 27 10:30:24 <remal>	singly
Mar 27 10:30:32 <caze>	What does it represent?
Mar 27 10:30:33 <Xgc>	remal: Then the casts like (struct node *) ... are probably a bad idea.
Mar 27 10:30:44 <remal>	just have no idea how many files it is gonna be
Mar 27 10:31:06 <caze>	Queue? Stack?
Mar 27 10:31:18 <Xgc>	remal: The same with (node *) casts.
Mar 27 10:31:35 <remal>	queue
Mar 27 10:35:54 <caze>	remal: You don't need that much duplicated code, tbh.
Mar 27 10:36:39 <remal>	wdym?
Mar 27 10:36:56 <caze>	https://bpa.st/OT2Q
Mar 27 10:37:14 <caze>	You don't need two mallocs.
Mar 27 10:38:17 <remal>	oh right, if a memory location is null it can be just written to.
Mar 27 10:38:48 <caze>	No.
Mar 27 10:40:26 <remal>	?
Mar 27 10:42:49 <caze>	remal: https://bpa.st/RRWA
Mar 27 10:44:32 <remal>	oh.
Mar 27 10:45:57 <caze>	But you can also put that into an enqueue function.
Mar 27 10:52:28 <remal>	Yeah, I should have sketched the structure of my program before jumping into getting the files
Mar 27 10:58:36 <caze>	remal: https://ideone.com/deBcOC
Mar 27 11:02:57 <caze>	remal: double pointers might be a little advanced.
Mar 27 11:03:53 <remal>	Yeah, just need to wrap my head around it.
Mar 27 11:04:16 *	TheMeltdown is now known as Guest46591
Mar 27 11:10:07 <caze>	remal: It's a little simpler if it's a stack. https://ideone.com/l2s29J
Mar 27 11:11:36 <remal>	I think I got it. Thanks caze
Mar 27 11:12:07 <caze>	remal: Do you know why push has to take a struct node **?
Mar 27 11:13:36 <remal>	not exactly no.
Mar 27 11:14:00 <remal>	I was thinking because the pointer gets modified
Mar 27 11:14:13 <caze>	Yes that's why.
Mar 27 11:14:28 <caze>	The pointer object in main gets modified.
Mar 27 11:14:29 <remal>	oh, alright then. The idea is just a little alien
Mar 27 11:15:23 <caze>	If you just pass the pointer, instead of a pointer to the pointer, then the function receives a copy of the pointer, and any modifications it does to the pointer is only done to a copy, and won't be reflected in the original.
Mar 27 11:16:08 <caze>	If you pass a pointer to the pointer, the function can dereference that pointer to reach the original pointer, and modify that.
Mar 27 11:17:33 <remal>	Yep, got it. I think I'm gonna play with it a bit, maybe try to implement a doubly ll after
Mar 27 11:18:33 <remal>	Why is it that free(str) works although it is const?
Mar 27 11:18:35 <caze>	Why? A doubly ll is completely different.
Mar 27 11:19:10 <caze>	A doubly ll can be interpreted as both a stack and a queue, and thus, neither.
Mar 27 11:19:12 <remal>	caze: a little harder, just want to practice working with pointers
Mar 27 11:19:24 <caze>	You won't learn much.
Mar 27 11:19:43 <caze>	There's more to be learned by studying singly linked lists.
Mar 27 11:19:51 <caze>	For instance, how to insert.
Mar 27 11:20:05 <remal>	well, we did that part
Mar 27 11:20:20 <caze>	remal: Insert into the middle of a list.
Mar 27 11:20:24 <remal>	oh
Mar 27 11:20:46 <remal>	so given a node in the middle insert after?
Mar 27 11:20:48 <dave0>	remal: memory you malloc is always writable.. you can use const and the compiler will check for you, but const doesn't change the underlying read/write-ness of the memory
Mar 27 11:21:00 <remal>	something like that? Oh an index would be synonymous.
Mar 27 11:21:11 <caze>	remal: free doesn't try to modify the memory.
Mar 27 11:21:33 <remal>	Doesn't it ?
Mar 27 11:21:39 <caze>	remal: No.
Mar 27 11:22:20 <remal>	       The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(
Mar 27 11:22:23 <remal>	)
Mar 27 11:22:26 <remal>	from the manual
Mar 27 11:22:32 <caze>	Yes.
Mar 27 11:22:41 <caze>	It frees it. It doesn't try to write to it.
Mar 27 11:22:55 <remal>	right
**** ENDING LOGGING AT Sat Mar 27 12:09:32 2021

**** BEGIN LOGGING AT Tue Mar 30 19:59:19 2021

Mar 30 19:59:19 *	Now talking on ##C
Mar 30 19:59:19 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 30 19:59:19 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 30 19:59:19 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 30 19:59:19 *	Channel ##c url: http://www.iso-9899.info/
Mar 30 21:47:32 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 30 21:47:32 2021

**** BEGIN LOGGING AT Tue Mar 30 21:50:00 2021

Mar 30 21:50:00 *	Now talking on ##C
Mar 30 21:50:00 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Mar 30 21:50:00 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Mar 30 21:50:02 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Mar 30 21:50:02 *	Channel ##c url: http://www.iso-9899.info/
Mar 30 21:55:37 <fizzie>	Well, as long as your chosen style isn't https://0x0.st/-b_U.c levels of odd.
Mar 30 21:58:02 *	Disconnected ()
**** ENDING LOGGING AT Tue Mar 30 21:58:02 2021

**** BEGIN LOGGING AT Thu Apr  1 20:57:30 2021

Apr 01 20:57:30 *	Now talking on ##C
Apr 01 20:57:30 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 01 20:57:30 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 01 20:57:30 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 01 20:57:30 *	Channel ##c url: http://www.iso-9899.info/
Apr 01 21:02:43 <wroathe>	xace_: You know what they say about there only being two hard things in programming, don't you?
Apr 01 21:04:36 <xace_>	hahaha, i'll keep that in mind from now on...
Apr 01 21:06:25 <wroathe>	xace_: There's only two hard things in programming: naming things, cache invalidation, and off by one errors.
Apr 01 21:07:01 <twkm>	today911: terminfo and curses come to mind, but they aren't the only ways.
Apr 01 21:07:08 <xace_>	haha now it sounds even funnier
Apr 01 21:07:41 <wroathe>	xace_: But joking aside... yeah, you get better at it. It takes practice.
Apr 01 21:08:11 <twkm>	let the compiler do the work.
Apr 01 21:08:39 <xace_>	that's reassuring :)
Apr 01 21:29:33 <today911>	twkm: thank you
Apr 01 21:38:58 <Joel>	I have ZERO C experience. Trying to switch from lastpass to bitwarden. In order to make this easier I'm trying to improve the json output. Original: https://github.com/lastpass/lastpass-cli/blob/HEAD/json-format.c Where I'm at: http://codepad.org/nMMlWjgt
Apr 01 21:39:32 <Joel>	I added the json_add_array_field method, but I'm struggling to understand how to make this code actually correct. I'm happy to google/read about what I might be doing wrong here.
Apr 01 21:40:00 <JohnnyVM>	what is lastpass?
Apr 01 21:40:02 <Nav|C>	smaller binary how? internet search = still nothing
Apr 01 21:40:35 <JohnnyVM>	Nav|C -Os and some functions for the linker can help
Apr 01 21:41:00 <JohnnyVM>	https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags#-ffunction-sections--fdata-sections----gc-sections
Apr 01 21:42:36 <JohnnyVM>	Joel, its a bit dificult understand what do you want
Apr 01 21:43:16 <fizzie>	Joel: That's a little much to read just for fun, but at least using `&value` on line 183 must almost certainly be wrong, because that's the address of a variable that's local to the function, and will stop existing as soon as the function returns.
Apr 01 21:45:57 <Joel>	fizzie yeah, found and fixed that, now I think I need to change L209, which is passing in a struct, I think it needs to just pass an array of strings, still reading.
Apr 01 21:59:13 *	Disconnected ()
**** ENDING LOGGING AT Thu Apr  1 21:59:13 2021

**** BEGIN LOGGING AT Thu Apr  1 22:03:36 2021

Apr 01 22:03:36 *	Now talking on ##C
Apr 01 22:03:36 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 01 22:03:36 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 01 22:03:36 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 01 22:03:36 *	Channel ##c url: http://www.iso-9899.info/
Apr 01 22:03:51 <xace_>	Nav|C: strip -s ./a.oout
Apr 01 22:03:56 <Nav|C>	?
Apr 01 22:04:16 <xace_>	if you dont want to include the metadata from the compiler and what not, strip it out of the executable
Apr 01 22:04:37 <xace_>	as to why it includes it: i guess its useful debugging information?
Apr 01 22:04:57 <Nav|C>	why is it there in the first place?
Apr 01 22:05:12 <Nav|C>	ok
Apr 01 22:05:14 <xace_>	altso cat ./a.out is cat abuse, use strings -a ./a.out
Apr 01 22:05:15 <Nav|C>	wierd lol
Apr 01 22:05:31 <xace_>	nobody likes cat abusers
Apr 01 22:05:37 <Nav|C>	heh?
Apr 01 22:06:21 <Nav|C>	after doing that, there is still os information
Apr 01 22:06:50 <Nav|C>	https://envs.sh/jG.txt
Apr 01 22:08:05 <xace_>	maybe gcc -s is relevant? not sure
Apr 01 22:09:01 <twkm>	Nav|C: so that it will work.
Apr 01 22:10:16 <Nav|C>	ok -s does the same as running gcc and then strip, it has same hash
Apr 01 22:10:20 <twkm>	feel free to make it so it won't work, e.g., for some platform you don't have.
Apr 01 22:10:21 <Nav|C>	well thanks
Apr 01 22:10:36 <Nav|C>	twkm: wdym?
Apr 01 22:13:04 <fizzie>	FWIW, there's more flags you can pass to strip, and some of the stuff it allows to remain by default definitely isn't in the column of necessary things. Like the linker build ID, that's strictly a convenience thing.
Apr 01 22:14:06 <lemonade`>	it seems that sometimes OS information in text strings is required. see https://marc.info/?l=openbsd-newbies&m=135427076832231&w=2
Apr 01 22:14:07 <candide>	Title of lemonade`'s link: 'Re: yasm - position independent code' - MARC
Apr 01 22:15:11 <xace_>	fizzie: are you saying -s doesnt remove all symbols? what else should be added in that case?
Apr 01 22:15:33 <fizzie>	It does remove all *symbols*, but there's other things than symbols.
Apr 01 22:15:46 <xace_>	like --discard-all maybe?
Apr 01 22:15:56 <xace_>	nvm it s ays symbols too...
Apr 01 22:16:37 <fizzie>	`strip --remove-section=.note.gnu.build-id` perhaps. Not that it really matters.
Apr 01 22:17:23 <fizzie>	It's just nice to have a build ID, saves guessing whether something's the same binary as something else.
Apr 01 22:22:46 <twkm>	Nav|C might also looking at the docs for the file and strings commands.
Apr 01 22:22:58 <Nav|C>	It's also nice if binaries will have the same hash regardless of ware thay were build (ofcourse except if it was built on diffrent cpu
Apr 01 22:23:33 <xace_>	not sure if reproducable builds is a simple thing to implement for all projects...
Apr 01 22:23:47 <Nav|C>	but this is hello world..
Apr 01 22:23:47 <fizzie>	Reproducible builds isn't also an argument against the build ID, because it too is reproducible.
Apr 01 22:24:46 <fizzie>	(The default build ID is a SHA-1 checksum of the linker inputs, so as long as those are the same, the build ID will be too.)
Apr 01 22:26:43 *	Disconnected ()
**** ENDING LOGGING AT Thu Apr  1 22:26:43 2021

**** BEGIN LOGGING AT Thu Apr  1 22:30:27 2021

Apr 01 22:30:27 *	Now talking on ##C
Apr 01 22:30:27 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 01 22:30:27 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 01 22:30:31 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 01 22:30:31 *	Channel ##c url: http://www.iso-9899.info/
Apr 01 22:31:30 <Ranhir>	Maestro
Apr 01 22:33:43 *	Disconnected ()
**** ENDING LOGGING AT Thu Apr  1 22:33:43 2021

**** BEGIN LOGGING AT Wed Apr  7 15:28:35 2021

Apr 07 15:28:35 *	Now talking on ##C
Apr 07 15:28:35 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 07 15:28:35 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 07 15:28:35 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 07 15:28:35 *	Channel ##c url: http://www.iso-9899.info/
Apr 07 15:28:36 <slidercrank>	,insult Biden
Apr 07 15:28:37 <candide>	Biden: If you were twice as smart, you'd still be stupid.
Apr 07 15:29:28 <ajak>	,mock slidercrank
Apr 07 15:29:29 <candide>	,InSuLt BiDeN
Apr 07 15:29:49 <JohnnyVM>	slidercrank, i am spanish XD
Apr 07 15:30:38 <slidercrank>	I figured. Lots of things give you away :)
Apr 07 15:31:24 <slidercrank>	the preceding 'e' in 'sp' and wrong prepositions. I know there is 'en' for English on/in/at in Spanish
Apr 07 15:31:26 <JohnnyVM>	XD i will take more care next time
Apr 07 15:32:05 <slidercrank>	JohnnyVM, "on wikipedia", not "in"
Apr 07 15:32:17 <slidercrank>	because it's a site.
Apr 07 15:34:48 <slidercrank>	,cc #define COUNTOF(n) sizeof(n)/sizeof(n[0]) \n char a[][4]={{1,2,3,4}, {5,6,7,8}}; \n printf("a has dimentions %ldx%ld\n", COUNTOF(a), COUNTOF(a[0]));\n
Apr 07 15:34:50 <candide>	slidercrank: error: stray '\17' in program
Apr 07 15:34:51 <JohnnyVM>	O.o ok, i will remember, i never understood the diference before XD
Apr 07 15:35:50 <JohnnyVM>	,insult JohnnyVM
Apr 07 15:35:51 <candide>	JohnnyVM: You're so stupid, you sold your car for gas money.
Apr 07 15:35:55 <slidercrank>	,cc #define COUNTOF(n) sizeof(n)/sizeof(n[0]) \n char a[][4]={{1,2,3,4}, {5,6,7,8}}; \n printf("a has dimentions %ldx%ld\n", COUNTOF(a), COUNTOF(a[0]));\n
Apr 07 15:35:57 <candide>	slidercrank: a has dimentions 2x4
Apr 07 15:38:41 <slidercrank>	,cjeopardy
Apr 07 15:38:42 <candide>	Please join #cjeopardy to play C Jeopardy!
Apr 07 15:43:30 <rl_[m]>	<slidercrank "rl_, you must specify all dimens"> I thought so myself, but perhaps I didn't know as much as I thought I did. It is so embarassing for C to not have this feature.
Apr 07 15:44:05 <twkm>	it doesn't even have multidimensional arrays, just arrays of arrays.
Apr 07 15:59:11 <tech_exorcist>	<slidercrank> ,cc #define COUNTOF(n) sizeof(n)/sizeof(n[0]) \n char a[][4]={{1,2,3,4}, {5,6,7,8}}; \n printf("a has dimentions %ldx%ld\n", COUNTOF(a), COUNTOF(a[0]));\n | why didn't you #include <stdio.h> ?
Apr 07 16:00:16 <twkm>	the bot does so for you.
Apr 07 16:00:23 <slidercrank>	tech_exorcist, why don't you ask why I didn't include int main()...? :)
Apr 07 16:00:29 <slidercrank>	because it works :)
Apr 07 16:01:01 <slidercrank>	makes using the bot easier
Apr 07 16:01:53 <tech_exorcist>	oh
Apr 07 16:02:03 <tech_exorcist>	I didn't think about main() tbh, oops
Apr 07 16:02:06 <tech_exorcist>	my bad
Apr 07 16:04:27 <twkm>	now the newline's before and after the printf seem odd to bother with.
Apr 07 16:05:31 <slidercrank>	you're right
Apr 07 16:25:07 *	lermain is now known as Jmtrix
Apr 07 16:52:23 *	tech_exorcist is now known as StupidNormie
Apr 07 16:53:09 *	StupidNormie is now known as tech_exorcist
Apr 07 18:51:23 *	Disconnected ()
**** ENDING LOGGING AT Wed Apr  7 18:51:23 2021

**** BEGIN LOGGING AT Wed Apr  7 18:51:48 2021

Apr 07 18:51:48 *	Now talking on ##C
Apr 07 18:51:48 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 07 18:51:48 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 07 18:51:49 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 07 18:51:49 *	Channel ##c url: http://www.iso-9899.info/
Apr 07 19:56:35 <Acacia>	yeah I thought something like that, just not so well written out. also it seems there is a non-0 amount of maintainers who don't share my eagerness to change these things
Apr 07 20:00:18 <JackB>	does anybody knows how to go from use case diagram to activity diagram?
Apr 07 20:00:26 <JackB>	do I make an activity diagram for each use case? or for the whole use case diagram
Apr 07 20:00:33 <JackB>	I am so confused
Apr 07 20:00:36 <JackB>	I am so confused
Apr 07 20:04:53 <twkm>	you probably want ##uml or ##cs.
Apr 07 20:17:15 <hypercube>	hello everyone, im working on implementing user-space threading in C for a class using SIGALRM for preemption, and ran into a little bit of an issue that i couldnt debug. essentially, whenever any client code wants to add a new thread, my initializer places a mask on SIGALRMS to prevent context-swapping in the middle of a critical operation, retrieves the new context where it will create the new thread
Apr 07 20:17:18 <hypercube>	and does everything correctly, but whenever i remove the mask before returning to the client code, i get a segmentation fault
Apr 07 20:20:40 <JohnnyVM>	? without know the implementation its dificult to say nothing, SIGSEV its a pretty common error
Apr 07 20:25:49 <hypercube>	JohnnyVM: sorry, ill go ahead and send the source right away
Apr 07 20:27:51 <hypercube>	https://pastebin.com/JdDCt59H
Apr 07 20:27:53 <hypercube>	this is the code
Apr 07 20:30:52 <hypercube>	the exact test case which causes this code to fail is this
Apr 07 20:31:32 <JohnnyVM>	https://godbolt.org/
Apr 07 20:31:47 <JohnnyVM>	can you reproduce you case with that?
Apr 07 20:31:59 <JohnnyVM>	and share the result
Apr 07 20:33:13 <hypercube>	absolutely
Apr 07 20:36:37 <Twix>	hypercube, why do you write your own scheduler? For learning?
Apr 07 20:36:56 <twkm>	the paste doesn't appear to be a testcase, in that it doesn't compile thus can't exhibit the issue.
Apr 07 20:37:31 <hypercube>	Twix: yes, it's for an operating systems class
Apr 07 20:38:05 <hypercube>	twkm: i realized that i had missed some of the methods, im using the site that JohnnyVM shared to set everything up
Apr 07 20:38:22 <Twix>	ah, okay. But woulnd't the dispatcher be the more interesting thing?
Apr 07 20:38:35 <twkm>	no methods in c, but indeed stuff is missing.
Apr 07 20:41:26 <Twix>	hypercube, you could also run your program in gdb and enter "bt" in the gdb shell after it crashed. It will print the backtrace
Apr 07 20:45:27 <hypercube>	Twix: i think that's probably what im going to do
Apr 07 20:46:02 <hypercube>	do you remember what the gcc option was for including extra information for debuggers to use?
Apr 07 20:46:09 <hypercube>	i cant quite recall
Apr 07 20:47:38 <lemonade`>	-g
Apr 07 20:47:41 <Twix>	-g
Apr 07 20:47:45 <Twix>	oh
Apr 07 20:47:49 <Twix>	:>
Apr 07 20:52:11 <hypercube>	awesome, thank you
Apr 07 20:58:50 <Unlimiter>	how do i free memory allocated by glewInit()?
Apr 07 21:04:14 <twkm>	you probably cannot, but if it is possible i'd expect the docs say how.
Apr 07 21:07:59 <Unlimiter>	twkm: where be?
Apr 07 21:09:09 <twkm>	the documentation?  i don't know.  but you are the one using the function so it's probably wise for you to locate the docs.
Apr 07 21:09:49 <novns>	Unlimiter, it depends on a platform, you can look different DestroyContext implementations in https://github.com/nigels-com/glew/blob/master/src/visualinfo.c
Apr 07 21:10:11 <novns>	and there's no magic function to free them all
Apr 07 21:10:23 <Unlimiter>	novns: then how am i supposed to write cross-platform stuff?
Apr 07 21:10:42 <Unlimiter>	i thought glew was cross-platform
Apr 07 21:10:58 <novns>	Unlimiter, or you can write just that one you support
Apr 07 21:11:08 <Unlimiter>	any cross-platform alternatives?
Apr 07 21:12:10 <novns>	you can use lower level opengl yourself, glew is just a nice tool
Apr 07 21:13:32 <novns>	and yes, you have to write cross-platform things in case of opengl
Apr 07 21:14:09 <novns>	or just stick to one platform of your choice, and never support anything else
Apr 07 21:16:23 *	Disconnected ()
**** ENDING LOGGING AT Wed Apr  7 21:16:23 2021

**** BEGIN LOGGING AT Thu Apr  8 13:03:10 2021

Apr 08 13:03:10 *	Now talking on ##C
Apr 08 13:03:10 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 08 13:03:10 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 08 13:03:10 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 08 13:03:10 *	Channel ##c url: http://www.iso-9899.info/
Apr 08 13:03:53 <oldlaptop>	It's also not (so far as I'm aware) ever part of a type declaration, the way * and [] can be.
Apr 08 13:06:16 <uskerine>	I think I saw somewhere (C++) that it can be used in functions https://stackoverflow.com/questions/1081811/c-vs-in-function-declaration
Apr 08 13:07:12 <dave0>	uskerine: c doesn't use that... in c, for the pseudo "reference", you add the * by hand
Apr 08 13:07:51 <uskerine>	ok
Apr 08 13:17:41 <oldlaptop>	that off-topic incremented-by-one language uses & in connection with one of its concepts, yes
Apr 08 13:18:07 <oldlaptop>	a wag might say that they decided * needed some company in the overused-characters club
Apr 08 13:24:09 <xace>	dave0: do you mean that foo(int *arr) is worse than foo(int arr[]) when the argument a is an array?
Apr 08 13:24:41 <fizzie>	,clang -fblocks -lBlocksRuntime int f(int (^p)(void)) { return p() + 1; } printf("%d", f(^(void){ return 1; })); // what about ^ joining the club?
Apr 08 13:24:44 <candide>	fizzie: 2
Apr 08 13:25:14 <fizzie>	^ would have been a nice symbol to use in pointer declarators, because it's pointy.
Apr 08 13:25:42 <dave0>	xace: yes if it is actually an array... i go further and put a number in the []'s to remind me of the size of the array (even though it is ignored)
Apr 08 13:27:47 <dave0>	fizzie: forth uses @ to fetch a word "at" an address !
Apr 08 13:28:12 <dave0>	pointy and at go together like pizza and anchovies
Apr 08 13:31:16 <xace>	what does (^p) mean? and what does ^(void){ return 1; }) mean?
Apr 08 13:31:32 <fizzie>	It means something that's not C.
Apr 08 13:31:46 <fizzie>	It's a Clang/Apple extension called "Blocks".
Apr 08 13:37:36 <Arthuria>	Hi. I need a way to extract data out of a wide char string. I'm thinking strtok wide equivalent. But it's relatively simple, get the bus/device/function values out. String format is always constant. https://onlinegdb.com/S1Det_hBu
Apr 08 13:40:41 <fizzie>	"strtok wide equivalent" would be wcstok, though it shares all the drawbacks of strtok.
Apr 08 13:42:01 <fizzie>	...actually, no, it doesn't. They fixed the possibly worst thing (the implicit static storage), it takes an extra `wchar_t **` parameter for state. Huh, didn't realize that. Well, that's nice.
Apr 08 13:42:11 <fizzie>	Still mangles up the original string, but it is what it is.
Apr 08 13:42:55 <fizzie>	swscanf's an option too, of course.
Apr 08 13:45:04 <fizzie>	,cc int bus, dev, fun; if (swscanf(L"PCI bus 62, device 4, function 0", L"PCI bus%d, device%d, function%d", &bus, &dev, &fun) == 3) printf("(%d,%d,%d)", bus, dev, fun);
Apr 08 13:45:06 <candide>	fizzie: (62,4,0)
Apr 08 14:08:37 <Arthuria>	Thanks Fizzie, swscanf is definitely better in this case than wcstok
Apr 08 14:21:29 *	candide removes channel operator status from candide
Apr 08 15:01:22 *	Disconnected ()
**** ENDING LOGGING AT Thu Apr  8 15:01:22 2021

**** BEGIN LOGGING AT Thu Apr  8 15:04:52 2021

Apr 08 15:04:52 *	Now talking on ##C
Apr 08 15:04:52 *	Topic for ##C is: C Programming | PASTE (>3 lines): http://codepad.org/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 08 15:04:52 *	Topic for ##C set by twkm!twkm@rfc1459.net (Mon Dec  9 19:03:31 2019)
Apr 08 15:04:53 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 08 15:04:53 *	Channel ##c url: http://www.iso-9899.info/
Apr 08 15:14:45 *	xtropro is now known as xtro
Apr 08 15:22:52 *	Disconnected ()
**** ENDING LOGGING AT Thu Apr  8 15:22:52 2021

**** BEGIN LOGGING AT Sun Apr 11 18:12:14 2021

Apr 11 18:12:14 *	Now talking on ##C
Apr 11 18:12:14 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 11 18:12:14 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 11 18:12:14 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 11 18:12:14 *	Channel ##c url: http://www.iso-9899.info/
Apr 11 18:19:58 *	Disconnected ()
**** ENDING LOGGING AT Sun Apr 11 18:19:58 2021

**** BEGIN LOGGING AT Sun Apr 11 18:23:31 2021

Apr 11 18:23:31 *	Now talking on ##C
Apr 11 18:23:31 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 11 18:23:31 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 11 18:23:32 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 11 18:23:32 *	Channel ##c url: http://www.iso-9899.info/
Apr 11 18:31:23 <pragma->	wroathe: but do you know why kids love the taste of cinnamon toast crunch?
Apr 11 18:32:20 <wroathe>	pragma-: That's easy. Sugar.
Apr 11 18:32:30 *	APic grins magically.
Apr 11 18:38:02 <nb-ben>	wroathe: do you know how to produce an EC private key from a public key in polynomial time?
Apr 11 18:38:16 <nb-ben>	wroathe: or how to make a quantum computer to do that
Apr 11 18:45:29 <wroathe>	nb-ben: Yes. Through math.
Apr 11 18:47:26 <nitrix>	https://i.imgur.com/xNWld3gh.jpg
Apr 11 18:47:49 <nitrix>	Use coding and algorithms.
Apr 11 18:48:05 <wroathe>	nitrix: It'll never work.
Apr 11 18:48:26 <nb-ben>	that's funny
Apr 11 18:56:29 <BlakSAM>	Shor's, but there aren't enough qbits yet
Apr 11 19:01:52 <wroathe>	"In 2019 an attempt was made to factor the number 35 using Shor's algorithm on an IBM Q System One, but the algorithm failed due to cumulating errors"
Apr 11 19:02:00 <wroathe>	https://en.wikipedia.org/wiki/Shor%27s_algorithm
Apr 11 19:02:11 <wroathe>	Sounds like there's some issues to work out
Apr 11 19:02:50 <wroathe>	TIL I'm smarter than a quantum computer
Apr 11 19:03:04 <BlakSAM>	Q system one is a generic quantum computer too, it's likely the first breakthroughs here will be A. in a specialized quantum computer, B. in some government facility that we won't hear about until 10 years later
Apr 11 19:03:53 <wroathe>	There's no way in hell that B hasn't happened already
Apr 11 19:04:13 <wroathe>	Or the governments would've been making a bigger stink about establishing backdoors
Apr 11 19:04:14 <BlakSAM>	well like you said, there are still some issues to address :P even for them
Apr 11 19:04:36 <wroathe>	Well, that's for the publicly available body of working on quantum computing
Apr 11 19:04:42 <wroathe>	body of work*
Apr 11 19:04:52 <BlakSAM>	yeah, I mean who knows I guess. Certainly not me
Apr 11 19:11:44 <nb-ben>	well there's a $1 trillion prize for a solution
Apr 11 19:14:07 <expert975>	when using call results as parameters of a function call, the calling order of the parameters is not defined. What if instead I'm using those results to initialize a struct? Is the call order defined in this case?
Apr 11 19:14:46 <fizzie>	The order of evaluation is not defined for initializer lists either, whether they're function calls or not.
Apr 11 19:15:02 <expert975>	fizzie: ok, thanks
Apr 11 19:15:52 <fizzie>	,c11 6.7.9p23
Apr 11 19:15:53 <candide>	http://www.iso-9899.info/n1570.html#6.7.9p23 [Initialization] The evaluations of the initialization list expressions are indeterminately sequenced with respect to one another and thus the order in which any side effects occur is unspecified.152) FOOTNOTE.152 In particular, the evaluation order need not be the same as the order of subobject initialization.
Apr 11 19:19:13 <expert975>	can I take the address of a compound literal?
Apr 11 19:21:32 <fizzie>	Yes.
Apr 11 19:21:57 <fizzie>	It's a modifiable lvalue, so you can even assign to it, though I've yet to find a reasonable use case for that.
Apr 11 19:22:18 <fizzie>	,cc (int){1} = 2;
Apr 11 19:22:21 <candide>	fizzie: Success (no output).
Apr 11 19:23:35 <fizzie>	Just keep in mind that at block scope it's got automatic storage duration associated with a block, and there are things that are a block that don't have the telltale {}s around them.
Apr 11 19:24:10 <fizzie>	,cc int *p; if (1) p = &(int){123}; printf("%d", *p); // undefined behavior
Apr 11 19:24:13 <candide>	fizzie: 123
Apr 11 19:25:23 <expert975>	I see. My usecase is to pass a structure to a function that copies its contents
Apr 11 19:27:05 <fizzie>	That's usually fine, because the compound literal will survive at least until the function call returns.
Apr 11 19:27:35 <expert975>	,cc struct s{int i;}; int func(int *i){return i}; printf("%d", func(&(struct s){.i=1}));
Apr 11 19:27:36 <candide>	expert975:  In function 'func':  warning: returning 'int *' from a function with return type 'int' makes integer from pointer without a cast [-Wint-conversion]  error: expected ';' before '}' token
Apr 11 19:27:46 <expert975>	,cc struct s{int i;}; int func(int *i){return *i}; printf("%d", func(&(struct s){.i=1}));
Apr 11 19:27:48 <candide>	expert975:  In function 'func':  error: expected ';' before '}' token
Apr 11 19:27:49 *	manuel___ is now known as Maaaanu
Apr 11 19:30:01 <expert975>	,cc struct s{int i;}; int func(struct s *s){return s->i;}; printf("%d", func(&(struct s){.i=1}));
Apr 11 19:30:03 <candide>	expert975: 1
Apr 11 19:30:11 <expert975>	there, that's what I meant
Apr 11 19:33:57 <wroathe>	expert975: Another thing to consider is that you get that for free just by passing the struct instead of a pointer to the struct
Apr 11 19:34:12 <wroathe>	expert975: int func(struct s s);
Apr 11 19:35:01 <wroathe>	(the copying behavior, that is)
Apr 11 19:37:54 <expert975>	wroathe: my function stores that input in another parameter, it doesn't need it on the stack. This is a vector implementation
Apr 11 19:53:12 <nitrix>	I prefer when vectors have a direction and a magnitude. The definition that everyone uses correctly, except the C++ committee.
Apr 11 19:55:39 <wroathe>	nitrix: Well, that definition has become the defacto standard in computing, thanks to the early work of the Bjarne and friends
Apr 11 19:56:13 <wroathe>	nitrix: Even Haskell, which is on the more pedantic side, has a Data.Vector that fits the bill
Apr 11 19:56:43 <wroathe>	I prefer teo call it a "resizing array" or something like that
Apr 11 19:56:46 <wroathe>	to*
Apr 11 19:56:59 <expert975>	I actually call my structure "List"
Apr 11 19:59:53 <begriffs>	IIRC, .NET uses the term "list" for the resizing array, whereas C++ and Ada use "vector"
Apr 11 20:01:33 <begriffs>	C++'s "list" has these names in other language standard libraries -- Ada doubly_linked_list, smalltalk linkedlist, .NET linkedlist, Java linkedlist
Apr 11 20:02:03 <begriffs>	Been investigating these terminology because I'm working on making (yet another) C collection library https://github.com/begriffs/libderp
Apr 11 20:02:31 <begriffs>	Want to have a vector, list, hashmap, and hashset initially.
Apr 11 20:05:46 <wroathe>	Call it YACL - Yet another container library
Apr 11 20:09:41 <et09>	this header file just has "struct cuse_dev;"
Apr 11 20:09:43 <et09>	what's that accomplish
Apr 11 20:09:55 <d3x0r>	begriffs https://github.com/d3x0r/SACK/blob/master/docs/tutorial/tutorial_containers.md (example is in tutorial_things.md it's nto well linked to itself yet)
Apr 11 20:10:22 <d3x0r>	defines a abstract/opaque type that will be used with further function definitions
Apr 11 20:10:28 <sham1>	Declares
Apr 11 20:10:34 <d3x0r>	ya
Apr 11 20:10:45 <et09>	what's the point of that
Apr 11 20:10:47 <sham1>	Don't worry. I get those mixed up as well :P
Apr 11 20:10:53 <begriffs>	d3x0r: thanks, taking a look
Apr 11 20:11:34 <sham1>	et09: it tells the compiler that "hey, this type we're using, it's defined *somewhere*, but maybe not in this file"
Apr 11 20:11:42 <d3x0r>	begriffs there's about 2x that actually available that falls under 'advanced' though 'peek with index' is pretty advanced
Apr 11 20:11:48 <et09>	i'm trying to find the definition lol
Apr 11 20:12:06 <d3x0r>	et09 why do you want the definition?
Apr 11 20:12:14 <d3x0r>	call a function that gives one back to you
Apr 11 20:12:22 <d3x0r>	like fopen() gives you a FILE
Apr 11 20:12:23 <et09>	i have one already
Apr 11 20:12:26 <fizzie>	A `struct foo;` declaration in a header makes it possible to also declare a function like `void munge(struct foo *p);` without exposing the contents of the structure to other code including the header.
Apr 11 20:12:32 <et09>	in this code im trying to fix
Apr 11 20:12:38 <sham1>	"Dynamic allocation? Blashemy!"
Apr 11 20:12:41 <et09>	it has:    struct cuse_dev *my_cuse_dev = cuse_dev_create(&evdev_cuse_methods, ed, NULL, 0, 0, 0660, "%s%d", EVDEV_CUSE_DEFAULT_DEVNAME, devid);
Apr 11 20:12:49 <d3x0r>	it's so you don't muck about with it outside fo the exposed function interface
Apr 11 20:13:01 <et09>	and in the docs it says, if it succeeds, it returns a cuse_dev structure, or NULL on failure
Apr 11 20:13:11 <et09>	i want to printf the result to console
Apr 11 20:13:14 <d3x0r>	it's something like mutation guarding it... protecting it from uncontrolled changes
Apr 11 20:13:22 <d3x0r>	%p
Apr 11 20:14:13 <begriffs>	d3x0r: that library is gigantic. :)
Apr 11 20:14:17 <sham1>	Mucking around in someone else's structs is rude
Apr 11 20:14:35 <et09>	0x0
Apr 11 20:14:35 <d3x0r>	begriffs it's evertyhing and 3 kitchen sinks :)  but it can't be much more than it is
Apr 11 20:14:37 <et09>	so it is null?
Apr 11 20:14:59 <d3x0r>	everything else is a app on top of it - might browse the networking interface sack exposes (which requires code to make work)
Apr 11 20:15:07 <d3x0r>	ya
Apr 11 20:15:09 <sham1>	et09: looks like it
Apr 11 20:15:11 <et09>	son of a bitch
Apr 11 20:15:25 <wroathe>	d3x0r: If you want to get users for that thing, you should really consider splitting it up into a family of libraries. I think most C/C++ developers have an aversion to kitchen sinks.
Apr 11 20:15:31 <et09>	im so deep into this project which is "get the multimedia keys on my keyboard to work"
Apr 11 20:15:35 <et09>	"on freebsd"
Apr 11 20:15:42 <d3x0r>	wroathe I did - and they're even single-source/header compileable
Apr 11 20:15:56 <et09>	which has turned into "fix a 10 year old userpace daemon for supporting USB HID devices"
Apr 11 20:15:57 <d3x0r>	but it still lacked tutorial like things :)
Apr 11 20:16:15 <d3x0r>	begriffs https://github.com/d3x0r/micro-C-Boost-Types
Apr 11 20:16:26 <d3x0r>	and I really shouldn't steal a name
Apr 11 20:16:28 <d3x0r>	or association
Apr 11 20:16:36 <d3x0r>	it's a WIP
Apr 11 20:16:48 <sham1>	Hmm, the docs associated with cuse_dev_create don't at least imply that it sets errno or anything
Apr 11 20:17:05 <begriffs>	d3x0r: dude you're prolific
Apr 11 20:17:10 <et09>	sham1: meaning what
Apr 11 20:17:37 <sham1>	et09: well if it doesn't set that, then one needs to find another way to see why the function failed
Apr 11 20:17:47 <et09>	mhm
Apr 11 20:17:47 <d3x0r>	but... it's all based on the common core of containers - any +1 library requires basically a good chunk of stuff
Apr 11 20:18:12 <sham1>	et09: I'm assuming that the program you've fixed has called cuse_init() before you're calling cuse_dev_create
Apr 11 20:18:23 <sham1>	If not, that needs to be fixed
Apr 11 20:18:47 <et09>	calls ucuse_init
Apr 11 20:18:58 <sham1>	Okay good
Apr 11 20:19:08 <et09>	do you happen to understand this lol
Apr 11 20:19:18 <sham1>	Well no, I'm just guessing
Apr 11 20:19:39 <sham1>	Anyway, the docs say "The device name can only contain a-z, A-Z, 0-9, dot, / and underscore characters"
Apr 11 20:19:50 <sham1>	That might be the next thing to look at
Apr 11 20:20:05 <et09>	it does
Apr 11 20:20:08 <et09>	just checked
Apr 11 20:20:10 <et09>	input/event1
Apr 11 20:20:14 <sham1>	Mhm
Apr 11 20:21:31 <d3x0r>	thats /dev/input/event1 ?
Apr 11 20:21:59 <et09>	i suppose so yeah
Apr 11 20:22:08 <sham1>	Looking at the sources I found somewhere, there seem to be three failure cases here
Apr 11 20:22:41 <d3x0r>	you suppose so?  so you didnt specify a full path to a device?
Apr 11 20:23:00 <et09>	no it's provided as EVDEV_CUSE_DEFAULT_DEVNAME
Apr 11 20:23:05 <et09>	which is input/event1
Apr 11 20:23:07 <d3x0r>	o
Apr 11 20:23:14 <lemonade`>	struct s; declares struct s as a struct, so it can be used in another definition. if there is a struct s2 with a member involving a type struct s, while struct s has a member involving a type struct s2, then there is a chicken and egg problem -- you can't define either struct first without already having defined the other. declaring just the struct tag as struct s; allows you do break this dependency cycle.
Apr 11 20:23:34 <d3x0r>	declaration
Apr 11 20:25:12 <sham1>	et09: anyway, looking at the sources for cuse_dev_create, I can only see three failure cases: f_cuse being less than zero (it's an FD set by cuse_init and since the program calls it, that's probably not it if the program survives), malloc failure (which seems unlikely) or a failing IOCTL
Apr 11 20:26:46 <et09>	im out of my depth
Apr 11 20:27:02 <et09>	officially
Apr 11 20:27:24 <sham1>	I'd probably ask on some relevant FreeBSD channel, but one recommendation I'd give is that since you're on FreeBSD, one thing that might help you figure out the problem is dtrace
Apr 11 20:27:42 <et09>	freebsd channel isnt useful
Apr 11 20:28:12 <et09>	i guess i could look into dtrace
Apr 11 20:28:55 <et09>	the bottom line problem im having is that this uhidd daemon is noticing the usb hid keycodes, starting the broadcast to "vkbd" and evdev, but then there are no attached evdev clients
Apr 11 20:29:04 <et09>	so while a TTY gets these keypresses, X doesn't
Apr 11 20:29:09 <et09>	that's my working theory at least
Apr 11 20:29:18 <et09>	thats how i got here
Apr 11 20:29:33 <sham1>	Hmm, sounds annoying
Apr 11 20:29:42 <sham1>	Well, I hope you find a solution :)
Apr 11 20:29:45 <et09>	yes, you'd think this would work on a vanilla install right?
Apr 11 20:29:50 <et09>	"volup"/"voldown"
**** ENDING LOGGING AT Sun Apr 11 21:36:03 2021

**** BEGIN LOGGING AT Tue Apr 13 11:10:07 2021

Apr 13 11:10:07 *	Now talking on ##C
Apr 13 11:10:07 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 13 11:10:07 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 13 11:10:07 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 13 11:10:07 *	Channel ##c url: http://www.iso-9899.info/
Apr 13 11:15:21 <mikoto-chan>	alch: funny how I found this in chapter 1, the author really likes throwing people head-first in the cold water
Apr 13 11:17:23 <alch>	mikoto-chan, you're reading "A Book on C"? :)
Apr 13 11:18:23 <mikoto-chan>	how does rand() work? is it system-dependent? in the book I'm reading all integers are of size e4 oand e5 but on my PC it prints numbers as big as e9 and e10
Apr 13 11:18:33 <mikoto-chan>	e referring to scientific notation
Apr 13 11:18:38 FiSHLiM plugin unloaded
**** ENDING LOGGING AT Tue Apr 13 11:18:38 2021

**** BEGIN LOGGING AT Fri Apr 16 17:20:55 2021

Apr 16 17:20:55 *	Now talking on ##C
Apr 16 17:20:55 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 16 17:20:55 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 16 17:20:55 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 16 17:20:55 *	Channel ##c url: http://www.iso-9899.info/
Apr 16 17:30:46 <shynoob>	lol cuppajoeman, I am not a complete noob
Apr 16 17:31:32 <wroathe>	He's just a shy noob. There's a difference.
Apr 16 17:31:54 <wroathe>	The "complete" noob has much more nutritional value, for one.
Apr 16 17:35:20 <garo>	hm, just googled 'volatile' and most info boils down to "a variable that can change unexpected"
Apr 16 17:35:38 <garo>	which would translate to : any variable
Apr 16 17:35:49 <garo>	s/which/which i/
Apr 16 17:35:52 <fstd>	i quickly googled adverbs and the info boils down to "you add a -ly"
Apr 16 17:36:24 <dho>	garo: no, not really. it means that the value may change outside the scope of the definitions of the standard.
Apr 16 17:36:52 <dho>	this is not true of any arbitrary variable.
Apr 16 17:37:20 <lemonade`_>	like from a different program. or by, say, a hardware peripheral
Apr 16 17:37:25 <caze>	garo: int i; i = 42; printf("%d\n", i); What do you expect to be output?
Apr 16 17:37:34 <garo>	42
Apr 16 17:37:38 *	lemonade`_ is now known as lemonade`
Apr 16 17:37:49 <garo>	how can it be something different ?
Apr 16 17:38:09 <caze>	garo: But if as you say, the value can be changed unexpected, then it doesn't have to be 42, does it?
Apr 16 17:38:16 <lemonade`>	like if a different program modifies it. or by, say, a hardware peripheral
Apr 16 17:38:35 <lemonade`>	shared memory
Apr 16 17:38:57 <garo>	but isn't a fork counted as the same program ?
Apr 16 17:39:12 <caze>	A fork spawns a different process.
Apr 16 17:39:20 <lemonade`>	it's a different process from the same executable file.
Apr 16 17:40:10 <lemonade`>	the OS effectively copies the state of the running program to make another
Apr 16 17:40:27 <garo>	good point, but doesn't the kernel block access to that memory if it's not shared ?
Apr 16 17:40:46 <wroathe>	Who says the kernel isn't the one modifying that memory?
Apr 16 17:40:46 <lemonade`>	not if you previously set it up to share it
Apr 16 17:40:56 <garo>	extremely good point !
Apr 16 17:41:29 <garo>	so it seems i was just lucky, from now one i'll use volatile
Apr 16 17:41:36 <wroathe>	garo: I think a better theoretical approximation for understanding volatile is that it elevates writing to and reading from memory to being an observable side effect of your program, in the same way that reading from or writing to a socket is a side effect
Apr 16 17:41:45 <garo>	and the mmap() can i do it more highlevel ?
Apr 16 17:43:20 <garo>	(but not as highlevel as using mpi) something inbetween mmap and mpi would be ideal
Apr 16 17:43:45 <lemonade`>	why do you want something more "high level"? what specifically are you looking for?
Apr 16 17:44:43 <garo>	mmap() feels really close to the hardware
Apr 16 17:45:13 <dho>	garo: it's more applicable to a case where you're dealing with device drivers
Apr 16 17:45:28 <wroathe>	It's not really. It's a system call, which means it's a basic unit of the interface that the kernel exposes to userland.
Apr 16 17:45:40 <wroathe>	There's an awful lot of software plumbing in the kernel that supports it.
Apr 16 17:45:42 <dho>	garo: for example, some drivers have port-based I/O protocols where you write a value to register A and value is yielded in register B
Apr 16 17:46:28 <dho>	that protocol is outside the scope of C, but if you use C to write the software, and the registers are memory mapped, then volatile allows the compiler to understand it must not assume that the memory representing register B (for example) hasn't changed since the last time it was read
Apr 16 17:46:37 <dho>	which it would be able to do normally, because it's a read-only value
Apr 16 17:49:36 <lemonade`>	mmap works with virtual addresses, not physical addresses, if that's what your concern is.
Apr 16 17:49:48 <fizzie>	POSIX named shared memory objects (arguably, a "higher-level" API) are utilized via mmap too. I don't think it *should* feel all that "low-level" or "close to hardware". Or even if it does, there isn't really an alternative.
Apr 16 17:53:37 <garo>	lemonade`: large advantage, nice
Apr 16 17:53:51 <fizzie>	That said, sharing a single long via mmap is kind of clunky, since mmap's granularity is the page. If that one value is all you *need* to share between the processes, fair enough, isn't much you can do about that. But you wouldn't want to do that sort of thing for a large number of individual long-sized chunks.
Apr 16 17:55:31 <garo>	at the moment, 1 unsigned long is enough. At the very most after adding a gigantic amount of useless features i might need 10
Apr 16 18:01:35 <sham1>	You might be able to do what you need with a socketpair(3)
Apr 16 18:01:48 <sham1>	Sorry, socketpair(2)
Apr 16 18:02:15 <sham1>	Or in general by using something like a FIFO or whatever
Apr 16 18:02:44 <sham1>	If you're not doing a lot of file transfer, shared memory is probably not worth it
Apr 16 18:04:08 <shynoob>	lol what did I miss
Apr 16 18:06:21 <JohnnyVM>	someone tested if the new stdint definition INT_FASTN_MIN ar usefull? i didnt found any benchmark
Apr 16 18:08:52 <garo>	Isn't sharing memory faster then creating sockets/fifo's ?
Apr 16 18:11:32 <fizzie>	"Do not communicate by sharing memory; instead, share memory by communicating", is what Go famously says. (Well, maybe it's not that famous.)
Apr 16 18:11:42 <fizzie>	Sure, a shared-memory thing might be the fastest way to move a whole lot of data from one process to another, but does that actually matter for your use case?
Apr 16 18:11:47 <fizzie>	(The programming model is quote different for a FIFO, socket, message queue or whatnot than for shared memory, though.)
Apr 16 18:13:38 <sham1>	I like that quote, and it often is the way one might be able to make concurrent programming nicer, and probably with fewer races and deadlocks, maybe
Apr 16 18:13:58 <sham1>	Since sharing memory of course might lead to needing things like mutexes
Apr 16 18:15:08 <caze>	shynoob: https://ideone.com/R8stv9
Apr 16 18:15:52 <shynoob>	caze, linked list?
Apr 16 18:15:55 <caze>	shynoob: Fill in the bodies of the functions push and pop. Change nothing else.
Apr 16 18:16:01 <shynoob>	oh
Apr 16 18:16:11 <shynoob>	LIFO
Apr 16 18:16:15 <shynoob>	is that what it is called
Apr 16 18:16:18 <kkd>	fizzie: but channels are also just ring buffers, right?
Apr 16 18:17:05 <sham1>	Either unbounded or bounded FIFOs. In the latter case it probably makes sense to implement as a ring buffer
Apr 16 18:17:30 <fizzie>	kkd: I've kind of consciously never looked under the hood, and I think that'd kind of go against the spirit of that quote. It's not really about what the facilities are, it's more about how you use them.
Apr 16 18:19:14 <sham1>	Of course, this idea of "don't communicate by sharing memory, share memory by communicating" is useful in Go, which is the context Rob Pike said it in, but it's also useful in C. Especially when one considers that the things that are communicating don't need to be the same process. Helpful for things like privilege separation as well
Apr 16 18:19:52 <caze>	shynoob: Also called a stack.
Apr 16 18:20:09 <caze>	shynoob: That's why the functions are named push and pop.
Apr 16 18:22:23 <kkd>	yeah, I do see the point they're trying to make (this 'trick' is also used in applications that do sharding of some workload, and in some cases simply communicating using message passing has proved to be much more performant than contending over a shared resource and generating more coherency traffic in the CPU).
Apr 16 18:23:26 <fizzie>	And re that comment that didn't get any answers, INT_FAST<N>_MIN is just a constant for the minimum representable value of the corresponding int_fast<N>_t integer type, so it's hard to imagine what sort of "benchmark" you could have for that. As for the types themselves... well, maybe, but I imagine it'd be quite situational.
Apr 16 18:24:08 <fizzie>	,cc int_fast8_t f8; int_fast16_t f16; int_fast32_t f32; int_fast64_t f64; ptype(f8); ptype(f16); ptype(f32); ptype(f64); // just out of curiosity
Apr 16 18:24:10 <candide>	fizzie:  f8 = signed char   f16 = long   f32 = long   f64 = long
Apr 16 18:25:14 <fizzie>	,c11 footnote.262
Apr 16 18:25:15 <candide>	http://www.iso-9899.info/n1570.html#FOOTNOTE.262 The designated type is not guaranteed to be fastest for all purposes; if the implementation has no clear grounds for choosing one type over another, it will simply pick some integer type satisfying the signedness and width requirements.
Apr 16 18:25:25 <sham1>	If you want the absolutely most portable way of storing at maximum 32-bit values, even if something like an int32_t isn't available. But as we can see, because they're not used that often, thye can display odd behaviours. Like being 64-bit integers on architectures like the (presumably amd64) that can handle 32-bit integers nicely on its own
Apr 16 18:25:48 <sham1>	Same with int_leastX_t and its corresponding stuff
Apr 16 18:27:04 <sham1>	You'd think that int_leastX_t and int_fastX_t (and their unsigned counterparts) would be equivalent to intX_t (and uintX_t respectively) on AMD64? But apparently not. Only int_fast8_t and int_least8_t seem to hit that
Apr 16 18:28:15 <caze>	I would think that it would default to its native word size so long as it's big enough.
Apr 16 18:31:01 <ian|>	is it okay to typedef something before defining it? https://paste.centos.org/view/63ef2656
Apr 16 18:31:31 <ian|>	it compiles
Apr 16 18:31:35 <caze>	Yes.
Apr 16 18:31:38 <ian|>	nice
Apr 16 18:32:01 <ian|>	i was putting it afterwards and it looked bad...
Apr 16 18:32:40 <ian|>	but not as bad as anonymous with typedef built in
Apr 16 18:37:19 <ian|>	oh one last thing
Apr 16 18:37:26 <ian|>	void *func; can contain a function pointer?!
Apr 16 18:37:40 <ian|>	never tested but if so... amazing
Apr 16 18:37:50 <twkm>	technically, no.
Apr 16 18:37:53 <caze>	ian|: POSIX allows it, but standard C does not.
Apr 16 18:38:03 <ian|>	hmm
Apr 16 18:38:36 <ian|>	posix defines some sort of C spec?!
Apr 16 18:39:31 <sham1>	The POSIX specification basically extends the C language insofar as what capabilities you have within a POSIX environment
Apr 16 18:39:37 <wroathe>	That's one of the funny quirks about C. It's impossible for mere mortals to keep track of which standards, if any, govern the behavior you're seeing when you just write a simple program
Apr 16 18:39:50 <wroathe>	Is it the C standard? POSIX? Compiler extension?
Apr 16 18:40:19 <caze>	C++
Apr 16 18:40:34 <wroathe>	Same story there
Apr 16 18:43:25 *	audiophile_ is now known as audiophile
Apr 16 18:44:02 <ian|>	well
Apr 16 18:44:06 <ian|>	just the way she blows
Apr 16 18:56:43 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 16 18:56:43 2021

**** BEGIN LOGGING AT Fri Apr 16 18:57:09 2021

Apr 16 18:57:09 *	Now talking on ##C
Apr 16 18:57:09 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 16 18:57:09 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 16 18:57:10 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 16 18:57:10 *	Channel ##c url: http://www.iso-9899.info/
Apr 16 18:59:29 <kkd>	https://developers.redhat.com/blog/2021/04/16/broadening-compiler-checks-for-buffer-overflows-in-_fortify_source/
Apr 16 18:59:59 <fizzie>	Re the `void *func` thing, while that can't, a `void (*func)(void)` -- or any other function pointer type -- can act as a "generic" function pointer, as long as you're careful to convert it back to the right type before using it. And as a corollary, a `union { void *obj; void (*func)(void); }` can store any kind of a pointer.
Apr 16 19:06:37 <JohnnyVM>	kkd nice read
Apr 16 19:14:10 <begriffs>	I have some static functions that I want to define at the bottom of a .c file. Thus I'll need to declare them at the top of the file so other functions can call them. Do I add the "static" keyword to the declaration, definition, or both?
Apr 16 19:15:10 <begriffs>	(Could also define them at the top of the file, getting around the issue, but I think the code reads better to move that internal stuff out of the way to the end)
Apr 16 19:17:23 <begriffs>	Nevermind, looks like 6.2.2 says "If the declaration of a file scope identifier for an object or a function contains the storage-class specifier static, the identifier has internal linkage." So it's a declaration thing.
Apr 16 19:18:00 <sham1>	Although one could argue that it looks more consistent if it's done in both the definition and the declaration
Apr 16 19:28:22 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 16 19:28:22 2021

**** BEGIN LOGGING AT Fri Apr 16 19:28:46 2021

Apr 16 19:28:46 *	Now talking on ##C
Apr 16 19:28:46 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 16 19:28:46 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 16 19:28:46 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 16 19:28:46 *	Channel ##c url: http://www.iso-9899.info/
Apr 16 19:32:22 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 16 19:32:22 2021

**** BEGIN LOGGING AT Fri Apr 16 19:35:48 2021

Apr 16 19:35:48 *	Now talking on ##C
Apr 16 19:35:48 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 16 19:35:48 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 16 19:35:48 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 16 19:35:48 *	Channel ##c url: http://www.iso-9899.info/
Apr 16 20:07:15 *	_d3x0r is now known as d3x0r
Apr 16 20:31:44 <mendel_munkis>	finding an entry-level C job is hard.
Apr 16 20:39:11 <pragma->	the trick is not to look for a c job but instead to look for a whatever job and then convince them to change it to c after you get hired
Apr 16 20:42:12 <Learath2>	C backend for a website? :P
Apr 16 20:48:15 <JohnnyVM>	pragma- from pragmatism XD
Apr 16 20:49:20 <JohnnyVM>	Hi in big programs with its the common practice for store the config info/cli etc? a global struct?
Apr 16 20:49:39 <JohnnyVM>	which*
Apr 16 20:50:16 <JohnnyVM>	which is the common practice*
Apr 16 20:51:22 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 16 20:51:22 2021

**** BEGIN LOGGING AT Fri Apr 30 04:48:17 2021

Apr 30 04:48:17 *	Now talking on ##C
Apr 30 04:48:17 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 04:48:17 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 04:48:17 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 04:48:17 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 05:10:53 <wroathe>	caze: You're rheotorical.
Apr 30 05:35:57 *	p[a]ddy is now known as paddyez
Apr 30 05:49:56 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 05:49:56 2021

**** BEGIN LOGGING AT Fri Apr 30 05:50:33 2021

Apr 30 05:50:33 *	Now talking on ##C
Apr 30 05:50:33 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 05:50:33 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 05:50:33 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 05:50:33 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 05:56:26 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 05:56:26 2021

**** BEGIN LOGGING AT Fri Apr 30 05:57:12 2021

Apr 30 05:57:12 *	Now talking on ##C
Apr 30 05:57:12 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 05:57:12 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 05:57:12 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 05:57:12 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 05:59:36 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 05:59:36 2021

**** BEGIN LOGGING AT Fri Apr 30 06:00:02 2021

Apr 30 06:00:02 *	Now talking on ##C
Apr 30 06:00:02 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 06:00:02 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 06:00:02 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 06:00:02 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 06:47:48 *	kashyaprushi_ is now known as kashyaprushi
Apr 30 07:38:15 *	kashyaprushi_ is now known as kashyaprushi
Apr 30 13:00:02 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 13:00:02 2021

**** BEGIN LOGGING AT Fri Apr 30 13:00:31 2021

Apr 30 13:00:31 *	Now talking on ##C
Apr 30 13:00:31 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 13:00:31 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 13:00:31 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 13:00:31 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 13:01:56 <cousteau>	btw, any reason you're writing *(*(a + i) + 1) and not a[i][1]?
Apr 30 13:02:02 <BASMAGE68>	yeah I get it but dont understand why extra parantheses fuck it all
Apr 30 13:02:17 <dave0>	BASMAGE68: it's weird.. you managed to malloc a 2d array, which newbies always have problems with... you use the god awful *(*(a)) but seem to have got it right... but you thought x=*(*(a)) somehow created an alias
Apr 30 13:02:18 <BASMAGE68>	no reasoning
Apr 30 13:02:37 <BASMAGE68>	I saw that implementation somewhere else so I sued it
Apr 30 13:02:40 <cousteau>	it wasn't extra parentheses, it was the fact that the if expression wasn't all of it wrapped in a pair of parentheses
Apr 30 13:02:49 <BASMAGE68>	is it a bad practice?
Apr 30 13:03:03 <cousteau>	it is ugly
Apr 30 13:03:23 <cousteau>	a[b] is the same as *(a+b) but looks much more readable
Apr 30 13:04:12 <cousteau>	so it is very recommended to write a[b] rather than *(a+b) if you want anyone to understand your code
Apr 30 13:04:13 <BASMAGE68>	what would I write here than     for(i=0;i<num;i++) {/*allocate some memory to the sides themselves*/
Apr 30 13:04:14 <BASMAGE68>	        *(a+i) = (float*)malloc(3*sizeof(float));
Apr 30 13:04:14 <BASMAGE68>	    }
Apr 30 13:04:14 <candide>	It had been 4 days and 17 hours since someone casted malloc (see !dontcastmalloc).
Apr 30 13:04:21 <dave0>	BASMAGE68: does your code actually sort first,second,third correctly?
Apr 30 13:04:26 <BASMAGE68>	yes
Apr 30 13:04:32 <cousteau>	oh also don't cast malloc
Apr 30 13:04:48 <dave0>	it's the worst code i've seen in a while but you managed to code it somehow correctly
Apr 30 13:05:01 <BASMAGE68>	why not? Doesnt it assign some space for me to work?
Apr 30 13:05:39 <cousteau>	and rather than stating the size of the TYPE you want to allocate, as in malloc(3 * sizeof (float)), it is recommended to use the size of the VARIABLE you want to allocate, like malloc(3 * sizeof **a)
Apr 30 13:05:51 <BASMAGE68>	@dave0 thanks ahahaha
Apr 30 13:06:09 <dave0>	who sorts by enumerating each possible permutation in code??
Apr 30 13:06:18 <BASMAGE68>	me :)
Apr 30 13:06:31 <dave0>	you turned a 10 line program into 100 lines
Apr 30 13:06:57 <dave0>	you give brute force a bad name lol
Apr 30 13:07:11 <BASMAGE68>	lmao, I mean I knew I could write that with ease instead of finding a sort function in google so I just coded that lol
Apr 30 13:07:35 <cousteau>	your code would be much more readable if you changed *(*(a+i)+j) into a[i][j]
Apr 30 13:07:55 <cousteau>	which means "the j-th component of the i-th element of a"
Apr 30 13:07:57 <BASMAGE68>	yeah also that wouldn require for me to cast malloc right
Apr 30 13:08:16 <dave0>	casting malloc is the least puzzling aspect of this code
Apr 30 13:08:17 <cousteau>	BASMAGE68: none of them requires you to cast malloc
Apr 30 13:08:34 <BASMAGE68>	oh, could I just delete malloc here than?
Apr 30 13:08:38 <cousteau>	malloc returns a pointer to void, which you can assign to any pointer variable without needing an explicit cast
Apr 30 13:09:10 <BASMAGE68>	can someone show me how the beginning of this code would look without malloc
Apr 30 13:09:31 <dave0>	float a[127][3];
Apr 30 13:10:09 <BASMAGE68>	so does this make a 3d array withe max 127 elements or what?
Apr 30 13:10:28 <dave0>	2d array.. 127 x 3
Apr 30 13:10:28 <cousteau>	no, it makes a 2D array of 127 x 3 elements
Apr 30 13:11:05 <cousteau>	(unless by "3D array" you meant "array of 3D vectors", which is a weird way to call it)
Apr 30 13:11:08 <BASMAGE68>	oh yeah 0 is considered itself right
Apr 30 13:12:25 <BASMAGE68>	float a[127][4]; so would this be 3d?
Apr 30 13:12:33 <dave0>	i don't know how you pieced this code together
Apr 30 13:12:37 <cousteau>	I'm not sure what you mean, but when you declare `a` as float a[127][3], then you can use it like a[i][j], where i has 127 possible values (from 0 to 126) and j has 3 possible values (from 0 to 2)
Apr 30 13:12:38 <dave0>	these are newbie questions
Apr 30 13:13:21 <cousteau>	so `a` is a 2D array (or a "matrix", or a table, if you prefer)
Apr 30 13:14:29 <cousteau>	you can imagine `a` as a table with 3 columns and 127 rows, containing 127*3 cells, each cell contains one float
Apr 30 13:16:00 <dave0>	i'm not sure how your teacher would grade this
Apr 30 13:16:19 <cousteau>	it depends on the teacher
Apr 30 13:18:07 <BASMAGE68>	sorry I needed to relog yeah a 127x3 matrix was my understanding
Apr 30 13:19:09 <BASMAGE68>	Oh so I iterate using the i and use j to access the sides than right
Apr 30 13:19:20 <BASMAGE68>	oh thats much easier wtf
Apr 30 13:19:32 <cousteau_>	you can iterate using j, yes
Apr 30 13:19:52 *	cousteau_ is now known as cousteau
Apr 30 13:20:08 <BASMAGE68>	also in this code, do I need to allocate malloc
Apr 30 13:20:11 <BASMAGE68>	or no
Apr 30 13:20:26 <cousteau>	"allocate malloc"??
Apr 30 13:20:36 <BASMAGE68>	cast sorry
Apr 30 13:20:49 <cousteau>	no, you never need to cast malloc
Apr 30 13:20:53 <BASMAGE68>	I meant aloocate memory like i did
Apr 30 13:21:07 <BASMAGE68>	than why is it a thing??
Apr 30 13:21:39 <cousteau>	if you make `a` with a fixed size like dave0 suggested then you don't need to malloc.  If you want to make it with a variable size then yes, you need malloc
Apr 30 13:22:11 <cousteau>	or, if your compiler supports it, you can make `a` a variable length array
Apr 30 13:22:32 <BASMAGE68>	oh so when I add +1 to a thats why I need malloc right
Apr 30 13:22:47 <cousteau>	scanf("%d", &num);  float a[num][3];
Apr 30 13:23:05 <cousteau>	...also you probably want to check the return value of scanf
Apr 30 13:23:13 *	kashyaprushi_ is now known as kashyaprushi
Apr 30 13:24:02 <cousteau>	no, you need malloc when you want to allocate an array of variable length
Apr 30 13:24:14 <BASMAGE68>	what does that mean
Apr 30 13:24:35 <cousteau>	that array is created somewhere in memory (that somewhere is called "allocated storage")
Apr 30 13:24:49 <cousteau>	and malloc then returns a pointer to the first element of that array that was created
Apr 30 13:25:32 <cousteau>	which, by the rules of the C syntax, can be used pretty much as if it were an array (although it's actually a pointer(
Apr 30 13:26:11 <cousteau>	I mean, when you do   int x[3];   you're declaring x as an array of 3 integers
Apr 30 13:26:54 <cousteau>	when you have a certain n, and want x to be an array of n integers, you'd do   int *x = malloc(n * sizeof *x)
Apr 30 13:27:10 <BASMAGE68>	oh so malloc could be x[i] basically?
Apr 30 13:27:31 <cousteau>	what do you mean?
Apr 30 13:27:45 <BASMAGE68>	so it could be 1 or 5 or 25
Apr 30 13:27:58 <BASMAGE68>	is that what you mean by variable lebgth
Apr 30 13:28:12 <cousteau>	yeah n could be any number you don't know when you're writing your program
Apr 30 13:28:52 <BASMAGE68>	I mean here I dont know how many rows there will be on my matrix tho
Apr 30 13:29:11 <BASMAGE68>	like array[i][3]
Apr 30 13:29:13 <cousteau>	like `num` in your example: you don't know what its value will be until the user enters the number, so unless you phone the user and ask them which number they intend to use with your program, you don't know the value of num at the time you're writing the program
Apr 30 13:30:01 <cousteau>	if you do   float array[num][3];   then array will be a table of num rows, and each row will contain 3 cells
Apr 30 13:30:10 <BASMAGE68>	so me not knowing beforehand doesnt matter as long as it is inputted before usage, is that it?
Apr 30 13:30:23 <cousteau>	yes
Apr 30 13:30:29 <cousteau>	but
Apr 30 13:31:09 <cousteau>	in old C (before C99, i.e. before 1999), and maybe in some implementations that don't support variable length arrays, you need to use constant values when declaring an array
Apr 30 13:31:33 <cousteau>	so   float array[127][3];   is OK, but   float array[num][3];   is not
Apr 30 13:32:23 <BASMAGE68>	oh o so basically in this case since I use C99 and the matrix structure is never changed it is absolutely needles to allocate the memory myself is that it
Apr 30 13:32:46 <cousteau>	C99 introduced "variable length arrays", which means that you can declare arrays of variable length (like float array[num][3];) directly
Apr 30 13:33:03 <cousteau>	if variable length arrays are not available, you are stuck with malloc
Apr 30 13:33:55 <cousteau>	yes, exactly, if your compiler supports variable length arrays then you can directly declare array as float array[num][3]; and forget about using malloc
Apr 30 13:34:21 <BASMAGE68>	also in my case I would write array [num][3] instead of float a[127][3] and scan the num right
Apr 30 13:34:54 <cousteau>	you first need to scan the num, and then declare the array
Apr 30 13:35:05 <BASMAGE68>	gotchya
Apr 30 13:35:25 <BASMAGE68>	thanks a lot for all the info, much appreciated
Apr 30 13:35:40 <cousteau>	if you change the value of num after declaring the array, the array will keep its old length, it won't automatically grow or shrink
Apr 30 13:36:16 <BASMAGE68>	oh nice, and I cant change the lenght since I didnt malloc right
Apr 30 13:37:23 <cousteau>	if you did malloc, you can use realloc to explicitly change its length, yes
Apr 30 13:38:37 <BASMAGE68>	so is malloc useless if you dont realloc>
Apr 30 13:38:58 <cousteau>	also, regardless of whether you used malloc or an array, you can use both *(*(array+i)+j) or array[i][j]
Apr 30 13:39:04 <cousteau>	Not really useless, it has its uses
Apr 30 13:39:23 <cousteau>	For example, creating an arbitrary number of arrays
Apr 30 13:39:30 <cousteau>	or pointers, in general
Apr 30 13:40:41 <cousteau>	That is used in linked lists.  A linked list is a bunch of elements consisting on a value and a pointer to the next element.  You can make that list as long as you want, but you can't just create one variable for each element because you don't know how many elements there are going to be
Apr 30 13:43:23 <John_Ivan>	hi, I am looking for a c to python transpiler. didn't find anything online. any ideas?
Apr 30 13:44:22 <cousteau>	I don't think I've ever heard the term "transpiler" before, so if you're googling that word you might want to use something else...
Apr 30 13:44:49 <ysftaha>	I think it is an idea from javascript
Apr 30 13:44:51 <John_Ivan>	cousteau, I tried "c to python converter" too.
Apr 30 13:44:57 <ysftaha>	transelator*
Apr 30 13:45:13 <cousteau>	I've used Cython before to combine Python code with C code.  Not exactly what you asked for but it could work for you
Apr 30 13:45:22 <cousteau>	also maybe #python knows better
Apr 30 13:45:27 <John_Ivan>	oh. there we go.
Apr 30 13:45:54 <ysftaha>	https://linux.die.net/man/1/ctopy
Apr 30 13:45:55 <candide>	Title of ysftaha's link: ctopy(1): quick/dirty C to Python translator) - Linux man page
Apr 30 13:45:56 <John_Ivan>	https://linux.die.net/man/1/ctopy
Apr 30 13:45:57 <candide>	Title of John_Ivan's link: ctopy(1): quick/dirty C to Python translator) - Linux man page
Apr 30 13:46:03 <John_Ivan>	yeah. beat me to it :)
Apr 30 13:46:05 <John_Ivan>	thans
Apr 30 13:46:06 <John_Ivan>	ks*
Apr 30 13:46:07 <ysftaha>	jinx
Apr 30 13:46:51 <cousteau>	Python also has an interface for C library functions I think... or at least CPython does (CPython is the most common implementation of Python, written in C, and you can write Python libraries in C)
Apr 30 13:46:56 <simpl_e>	I wonder if there is sucn a transpiler that supports standard C
Apr 30 13:47:15 <simpl_e>	s/sucn/such
Apr 30 13:47:22 <kashyaprushi>	use libpython-dev on linux
Apr 30 13:47:36 <John_Ivan>	yeah, I guess. but I'm not doing this out of lack of interop
Apr 30 13:47:44 <kashyaprushi>	You will get c interface for creating python lib
Apr 30 13:47:47 <ysftaha>	out of curiosity what is the point of this?
Apr 30 13:47:49 <John_Ivan>	I'm doing it simply out of disgust of the python language.
Apr 30 13:48:51 <cousteau>	you don't like python and want to transform C code into more python??
Apr 30 13:49:30 <John_Ivan>	cousteau, yeah. to give me the capability to use python libraries directly as labels in my C code.
Apr 30 13:49:42 <cousteau>	that's like not liking cats and then transforming all the dogs around you into cats!
Apr 30 13:49:43 <John_Ivan>	cousteau, it is until I write my c dlls so that I replace these stubs
Apr 30 13:49:55 <John_Ivan>	and then discard the python transpiler
Apr 30 13:50:26 <cousteau>	maybe you want to have a look at Cython
Apr 30 13:50:29 <John_Ivan>	cousteau, I dislike cats heavily.
Apr 30 13:50:32 <John_Ivan>	cousteau, no. I don't.
Apr 30 13:50:36 <John_Ivan>	I don't want to write ANY python. whatsoever.
Apr 30 13:50:49 <John_Ivan>	I want to focus solely on my C code.
Apr 30 13:50:56 <John_Ivan>	I don't care what gets spewed out.
Apr 30 13:51:15 <cousteau>	so why use python at all?
Apr 30 13:51:15 <John_Ivan>	and eventually, once I finish my C dlls, then I'll replace them instead of the python labels
Apr 30 13:51:25 <John_Ivan>	cousteau, because it provides the convenience that C doesn't have.
Apr 30 13:51:29 <John_Ivan>	as libraries
Apr 30 13:51:33 <John_Ivan>	that C would otherwise have had
Apr 30 13:51:39 <John_Ivan>	but everyone left such a beautiful language
Apr 30 13:51:39 <candide>	John_Ivan: Please stop abusing the enter key. Feel free to type longer messages and to take a moment to think of anything else to say before you hit that enter key.
Apr 30 13:51:39 <John_Ivan>	to rot
Apr 30 13:51:53 <John_Ivan>	Alright.
Apr 30 13:52:56 <John_Ivan>	I'm partially filled with rage. Sorry. I have a huge hatred for the nonsensical interpreted crap that has been produced and embroidered with convenience.
Apr 30 13:53:15 <John_Ivan>	That should have existed in C as well, but it was merely abandoned.
Apr 30 13:54:30 <John_Ivan>	cousteau, think of my transpiler a way for me to attempt a surrogate at getting what I want done faster, and implement the dlls later, which will then replace python completely.
Apr 30 13:55:27 <John_Ivan>	cousteau, it's like attempting to build a house out of stone, but first building it out of wood, so that I can get the foundation right done in stone. when the wooden frame is complete, it will then act as tracing/scaffold for me to work on top of in stone.
Apr 30 13:55:47 <John_Ivan>	once the stone is there, I can discard the wood.
Apr 30 13:56:09 <henistein>	How can I solve headers hieararchy problem here? https://pastebin.com/zjC0Qyxt
Apr 30 13:57:28 <cousteau>	henistein: use include guards
Apr 30 13:58:01 <cousteau>	content of foo.h:   #ifndef FOO_H_   #define FOO_H_   <... rest of code of foo.h ...>   #endif
Apr 30 13:58:45 <cousteau>	alternatively, most compilers accept   #pragma once   but that's not standard
Apr 30 14:00:31 <henistein>	Oh ok I have to learn more about include guards, do you know some good place to learn it?
Apr 30 14:00:57 <cousteau>	henistein: it's those three lines I mentioned
Apr 30 14:01:51 <henistein>	Yes it works, thank you
Apr 30 14:02:31 <cousteau>	basically, the first time you include foo.h, the macro FOO_H_ isn't defined yet, so #ifndef FOO_H_ is true, and everything until the #endif gets included
Apr 30 14:03:04 <cousteau>	the first thing after the #ifndef is a definition of a FOO_H_ macro, so after including foo.h for the first time, that macro will be defined
Apr 30 14:03:46 <cousteau>	the second time you include foo.h, the macro FOO_H_ already exists, so the #ifndef FOO_H_ is false, so everything until the #endif is omitted
Apr 30 14:04:15 <cousteau>	You're supposed to put those in all your .h files
Apr 30 14:05:29 <cousteau>	so also a #ifndef LIB1_H_ in your lib1.h and a LIB2_H_ in your lib2.h
Apr 30 14:06:27 <cousteau>	(you can get creative with the name of the macro; in this case I used "FOO_H_" because it looks like "foo.h" but has an unusual underscore at the end so it is unlikely that you'll be defining a macro or variable with that name anywhere else)
Apr 30 14:27:14 <hkm>	hi, is it bad practice to write structs in tentative definition form: struct {…} x;
Apr 30 14:27:41 <hkm>	since the scope is limited to the whole file
Apr 30 14:33:05 <nitrix>	Let me check the recommended reference manual of good standard idiomatic best practices.
Apr 30 14:36:59 <nitrix>	The scope is determined by the placement of the declaration. Within a block it has block-scope, within a function is has function scope, outside a function it has file scope, so on. (C11 6.2.1p4)
Apr 30 14:38:43 <hkm>	the unlazy thing would be to use a pointer to the struct but would it wrong to access the struct as if it was a group of global variables
Apr 30 14:39:17 <nitrix>	It would be more wrong to think C even has global variables.
Apr 30 14:41:41 <hkm>	that's interesting. not sure what it means; are you saying that the stack creates an illusion of global scope?
Apr 30 14:42:05 <nitrix>	You're digging a deeper hole now. C doesn't have a stack either.
Apr 30 14:42:41 <hkm>	stop haha
Apr 30 14:42:51 <nitrix>	,stack
Apr 30 14:42:51 <candide>	C does not require implementations to use stacks or heaps. Please refer to the actually defined storage durations, which are four: allocated, automatic, thread and static.
Apr 30 14:43:07 <hkm>	seriously can you explain what that means nitrix about the global variables
Apr 30 14:43:23 <hkm>	thanks candide
Apr 30 14:43:24 <candide>	My pleasure, h​km
Apr 30 14:43:26 <nitrix>	What part confuses you?
Apr 30 14:44:05 <hkm>	why is there no such as a global variable? do you see them as automatic variables with filewide scope instead?
Apr 30 14:45:37 <nitrix>	Because there isn't any scope that correspond to the generally understood definition of "global". File-scope is the closest and that limits you to the current translation unit.
Apr 30 14:46:15 <nitrix>	C has the concept of visibility between translation units, you can use `extern`, but that's orthogonal to scoping.
Apr 30 14:47:24 <nitrix>	As for "automatic variables", I have no idea why you think storage durations have anything to do with this.
Apr 30 14:49:19 <hkm>	Ah i see, thank you
Apr 30 14:52:24 <hkm>	Back to the question I was asking, would it be bad practice to declare a struct (struct {…} x;) with a file-scope which allows me to access it without a pointer or a Struct variable with a function scope?
Apr 30 14:52:52 <hkm>	I would be able to access x.count or x.letter from any function without passing a variable
Apr 30 14:54:57 *	Guest60658 is now known as julian
Apr 30 14:55:19 <fizzie>	Just as an unrelated terminology nitpick, a declaration of an ordinary identifier will never have function scope. Labels are the only things in the language that have function scope. Variables will always have file scope or block scope. (The block might well be the block statement that makes up a function body, but it's still not strictly function scope.)
Apr 30 14:56:35 <hkm>	oh good catch
Apr 30 14:57:24 <hkm>	im hoping to learn a lot more about how C truly works once I learn about compilers
Apr 30 15:31:02 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 15:31:02 2021

**** BEGIN LOGGING AT Fri Apr 30 15:31:28 2021

Apr 30 15:31:28 *	Now talking on ##C
Apr 30 15:31:28 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 15:31:28 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 15:31:28 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 15:31:28 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 15:44:36 *	mendelmunkis is now known as mendel_munkis
Apr 30 16:23:31 <grummund>	Can printf justify the *trailing* chars of a string into a fixed field width?  e.g. "veery looong striiingg" -> "iiingg"
Apr 30 16:24:03 <grummund>	justify and crop, that is.
Apr 30 16:31:41 <pragma->	You can use simple pointer arithmetic to pass the trailing characters of a string.
Apr 30 16:32:19 <pragma->	,cc char s[] = "a very long string";   printf("%s", s + strlen("a very long "));
Apr 30 16:32:22 <candide>	pragma-: string
Apr 30 16:40:00 <grummund>	#define TRACE() printf("%s:%d", __FILE__ + (((strlen(__FILE__) - 8) < 0)? 0:(strlen(__FILE__) - 8)), __LINE__)
Apr 30 16:40:07 <grummund>	something like that maybe.
Apr 30 16:42:09 <dyeplexer>	you can also replace strlen with (sizeof(__FILE__)/sizeof(__FILE__[0]) )) - 1) since __FILE__ is always substituted with a char array
Apr 30 16:42:30 <grummund>	ah thank you :)
Apr 30 17:31:29 <Gustavo6046>	Is there a shorthand for x = !x ? Perhaps an unary one?
Apr 30 17:31:43 <Gustavo6046>	Like, nothing wrong with ' curr_menu.up = !curr_menu.up ', but it can be a bit tedious to write.
Apr 30 17:32:02 <Gustavo6046>	Then again, I'm used to writing tediously. Honestly, I love it! C is so simple that I don't mind, and it's just a breeze at the end
Apr 30 17:32:34 <grummund>	x ^= ~0; // ?
Apr 30 17:32:40 <Gustavo6046>	hmm, maybe?
Apr 30 17:32:41 <fizzie>	There's no "reasonable" shorthand, IMO.
Apr 30 17:32:44 <Gustavo6046>	and, I see
Apr 30 17:32:53 <Gustavo6046>	That is fair enough :)
Apr 30 17:32:58 <Gustavo6046>	I'll just go the readable way I was doing, then
Apr 30 17:33:01 <Gustavo6046>	:D
Apr 30 17:35:21 <fizzie>	,cc int a = 0, b = 0; a = !a; b ^= ~0; printf("%d != %d", a, b);
Apr 30 17:35:24 <candide>	fizzie: 1 != -1
Apr 30 17:35:49 *	grummund misread the question
Apr 30 17:36:58 <fizzie>	Of course you *can* use ^= to toggle a value between 0 and 1 too, but it doesn't have exactly the same semantics if the initial/previous value happens to be something else than 0 or 1.
Apr 30 17:38:16 <fizzie>	Though I guess if it happens to be a `bool`, that wouldn't be an issue. Still, `curr_menu.up ^= 1` isn't quite as immediately obvious.
Apr 30 17:39:04 <grummund>	one would hope a decent compiler would the same however you wrote it.
Apr 30 17:41:34 <fizzie>	It can't be the same if it doesn't do the same thing. :) But I'd be really mostly concerned about how it reads to a human rather than a machine.
Apr 30 17:43:42 <wroathe>	Gustavo6046: fizzie: Did we mention a macro yet? #define flip(x) x = !x \n flip(curr_menu.op);
Apr 30 17:43:44 <grummund>	true
Apr 30 17:51:12 <fizzie>	Yeah. It's one of those macros where multiple evaluation is a problem, though. `while (*p) flip(*p++);` and so on.
Apr 30 17:52:14 <fizzie>	Er, maybe not exactly that plausible a scenario, but anyway.
Apr 30 17:55:14 <Gustavo6046>	ah
Apr 30 17:55:17 <Gustavo6046>	true
Apr 30 17:55:26 <Gustavo6046>	grummund: very boolean of us, innit :D
Apr 30 17:55:36 <Gustavo6046>	anyway, I was trying to write some code to help a russian friend learn C.. or something.
Apr 30 17:55:46 <Gustavo6046>	It was a hypothetical menu handling code. I don't know if it's too convoluted or anything https://bpa.st/PKFQ
Apr 30 17:58:21 <Gustavo6046>	ack I scratched my eye too much
Apr 30 18:00:45 <Gustavo6046>	and, oops, I screwed up array syntax in structs. I'm so embarassed and kinda mad at myself
Apr 30 18:03:03 <Gustavo6046>	This compiles, to object anyway (doesn't link but it's not meant to anyway) https://bpa.st/3RIA
Apr 30 18:04:48 <grummund>	(sizeof(__FILE__)/sizeof(__FILE__[0])) <-- is the "/sizeof(__FILE__[0])" effectively redundant?
Apr 30 18:05:30 <pragma->	the size of char is always 1
Apr 30 18:05:46 <grummund>	yes, that's what i mean.
Apr 30 18:06:05 <pragma->	the ()'s are unnecessary and make it harder to read, too.
Apr 30 18:06:26 <Gustavo6046>	what about a context where __FILE__ is an array of (AKA pointer to) a different type?
Apr 30 18:06:29 <Gustavo6046>	like const int *
Apr 30 18:06:30 <pragma->	,cc sizeof __FILE__;
Apr 30 18:06:32 <candide>	pragma-: no output: sizeof __FILE__ = 22
Apr 30 18:06:38 <Gustavo6046>	oh nvm, it's standard
Apr 30 18:06:39 *	pragma- squints at 22.
Apr 30 18:06:44 <pragma->	,cc __FILE__
Apr 30 18:06:47 <candide>	pragma-: no output: __FILE__ = "prog.c"
Apr 30 18:07:30 <Gustavo6046>	,cc strlen(__FILE__)
Apr 30 18:07:34 <candide>	Gustavo6046: Success (no output).
Apr 30 18:07:36 <pragma->	I think candide is silently stripping part of the output.
Apr 30 18:08:03 <Gustavo6046>	hang on
Apr 30 18:08:07 <Gustavo6046>	,cc printf("%d\n", strlen(__FILE__))
Apr 30 18:08:09 <candide>	Gustavo6046: [warning: format '%d' expects argument of type 'int', but argument 2 has type 'size_t' {aka 'long unsigned int'} [-Wformat=]] 6
Apr 30 18:08:23 <Gustavo6046>	prog.c is six letters (dot is a letter, prove me wrong!!!!11)
Apr 30 18:08:27 <Gustavo6046>	win win :D
Apr 30 18:08:45 <pragma->	It is. The full __FILE__ is actually:  no output: __FILE__ = "/home/compiler/prog.c
Apr 30 18:08:58 <Gustavo6046>	Oh.
Apr 30 18:09:01 <pragma->	It silently strips /home/compiler/ and other lines to make the output concise.
Apr 30 18:09:26 <pragma->	That has caused some confusion previously. I should revisit how I do that.
Apr 30 18:09:27 <Gustavo6046>	Ah
Apr 30 18:09:43 <pragma->	But I probably won't. But I should.
Apr 30 18:09:59 <Gustavo6046>	Confusion? That could be useful! If you're running away from some mob, you can just do the __FILE__ thing and everyone will be too confused to keep chasing you :D
Apr 30 18:16:52 <grummund>	pragma-: you dislike unecessary parenthesis?
Apr 30 18:19:32 <pragma->	grummund: Unnecessary ones that add no value and make the line longer and harder to read? Yes.
Apr 30 18:20:53 <grummund>	#define TRACE() printf("%s:%d", __FILE__ + ((int)sizeof __FILE__ - 8 < 0 ? 0 : sizeof __FILE__ - 8), __LINE__)
Apr 30 18:20:59 <grummund>	:P
Apr 30 18:29:55 <kurahaupo>	grummund: why cast to int and make a signed comparison, rather than just (sizeof __FILE__ < 8)?
Apr 30 18:30:30 <grummund>	kurahaupo: no reason, thanks for pointing it out.
Apr 30 18:30:50 <kurahaupo>	just checking I hadn't missed something
Apr 30 18:31:40 <trmi_>	what's the C channel where I can discuss non-portable/OS specific stuffs?
Apr 30 18:32:22 <twkm>	here's fine.  there might be more focused channels though.
Apr 30 18:33:26 <trmi_>	oh ok. So I'm reading raw tty input, and I need to differentiate between just Esc being pressed, and something like a function key which starts with Esc followed by other chars. I've seen some ideas based on using "select", but not all OS's I care about have that. Any ideas?
Apr 30 18:34:11 <kurahaupo>	trmi_: Posix tty devices having timing built in for just this kind of thing
Apr 30 18:34:30 <trmi_>	kurahaupo: you mean VMIN/VTIME?
Apr 30 18:34:39 <kurahaupo>	y yes
Apr 30 18:34:43 <trmi_>	i played with that, but reading blocks no matter what
Apr 30 18:35:18 <trmi_>	so if I read an Esc, then the next read from stdin shouldn't block if it's ESC alone
Apr 30 18:35:35 <kurahaupo>	Don't do multiple reads, do just one
Apr 30 18:36:21 <trmi_>	oh, so try to read the maximum possible input (the longest esc sequence) in one go?
Apr 30 18:36:27 <trmi_>	and it'll return what's available
Apr 30 18:36:27 <kurahaupo>	If you fill the buffer on the first read then set VMIN to 0 for the follow up read
Apr 30 18:36:50 <trmi_>	hm
Apr 30 18:37:08 <trmi_>	that would require a tcsetattr call every time
Apr 30 18:37:18 <kurahaupo>	basically yes. But be ready to keep reading to handle the case where the user pastes a big chunk in one go
Apr 30 18:37:23 <twkm>	usually you can't really determine the difference at the tty level, between communications related delays in the sequence and no sequence merely something close.  as such you might set a "large" (100ms) timeout on having read an esc then nothing to mean esc was pressed.
Apr 30 18:37:41 <kurahaupo>	not every time, just when you have an unusually long read
Apr 30 18:39:20 <kurahaupo>	Even when dealing with real terminals in real serial ports, the only time that there would be more than a single bittime delay in the middle of a sequence is if the DTE asserted hardware flow control
Apr 30 18:39:25 <kurahaupo>	err, DCE
Apr 30 18:39:47 <twkm>	modem retrain can be quite lengthy.
Apr 30 18:40:38 <twkm>	whether flow control was asserted depends, i.e., was not always done.
Apr 30 18:40:45 <kurahaupo>	High speed modems generally use a version of Nagle's algorithm to pack out sent packets over the wire
Apr 30 18:41:13 <twkm>	the same can be said of tcp, there might be a significant delay occur.
Apr 30 18:41:25 <kurahaupo>	Point is, it's theoretically possible but vanishingly unlikely
Apr 30 18:41:59 <trmi_>	so what you recommend is TRYING to read N of bytes with low VTIME? where N is the longest escape sequence I expect?
Apr 30 18:42:14 <trmi_>	if only one byte and that's ESC, then it's just ESC
Apr 30 18:42:18 <kurahaupo>	basically yes, and VMIN=1
Apr 30 18:42:29 <trmi_>	I see
Apr 30 18:42:39 <trmi_>	what's a good VTIME in practice?
Apr 30 18:43:09 <trmi_>	i need this to work both locally and over ssh
Apr 30 18:43:15 <kurahaupo>	If you fill the whole buffer, set VMIN=0 and append-read, and repeat as long as you keep filling, then set VMIN=1
Apr 30 18:43:33 <kurahaupo>	ssh -t presents a pty device
Apr 30 18:43:49 <trmi_>	whole buffer, hm, won't I risk the next read blocking?
Apr 30 18:44:00 <trmi_>	oh wait VMIN=0
Apr 30 18:44:10 <kurahaupo>	click
Apr 30 18:44:27 <trmi_>	got enough to experiment, thanks!
Apr 30 18:45:18 <trmi_>	kurahaupo: pty device? haven't used that, do I want that when using ssh?
Apr 30 18:45:21 <kurahaupo>	trmi_: Pick the largest delay that won't bother a human; 33 deciseconds is probably acceptable
Apr 30 18:45:45 <trmi_>	sounds good
Apr 30 18:45:59 <kurahaupo>	a pty looks to the program like a tty, but instead of a device on the other side there's a program such as sshd
Apr 30 18:46:20 <kurahaupo>	err, 33 centiseconds, oops
Apr 30 18:46:53 <trmi_>	yeah i mean, my program will be running on the host so I should only worry about delays from the user typing
Apr 30 18:47:29 <trmi_>	i ssh in, start the program, want great Esc handling :D
Apr 30 18:47:35 <kurahaupo>	Oh in that case VTIME=1 is ample time for communication
Apr 30 18:47:55 <kurahaupo>	oh no, that was for your previous comments
Apr 30 18:48:37 <trmi_>	not clear to me why reading a single byte blocks if VTIME and VMIN is 0
Apr 30 18:48:54 <trmi_>	(testing locally)
Apr 30 18:48:56 <kurahaupo>	Oh that's a special case
Apr 30 18:49:02 <trmi_>	oh
Apr 30 18:49:29 <kurahaupo>	You can also set the fd to nonblocking
Apr 30 18:49:54 <trmi_>	stdin too?
Apr 30 18:50:18 <kurahaupo>	yes fd#0 if applicable
Apr 30 18:50:28 <trmi_>	interesting
Apr 30 18:51:02 <trmi_>	kurahaupo: wait, did you mean VTIME/VMIN both being 0 is a special case, or reading a single byte being a special case?
Apr 30 18:51:24 <kurahaupo>	I've worked through all this stuff several times over, but the most recent was probably 10+ years ago so I'm a bit rusty
Apr 30 18:51:40 <kurahaupo>	both 0 is a special case
Apr 30 18:51:44 <trmi_>	i'm blocking no matter what i'm trying with vtime/vmin, hm
Apr 30 18:52:03 <trmi_>	yeah, both 0 is "This is a completely non-blocking read" according to docs
Apr 30 18:52:12 <trmi_>	so why reading a byte blocks...
Apr 30 18:52:29 <kurahaupo>	hmm, odd. Code paste?
Apr 30 18:52:47 <trmi_>	it's a hot mess, but i'll try to make a testcase if i can't make it work
Apr 30 18:53:01 <kurahaupo>	(will look but not on a PC so can't debug)
Apr 30 18:53:21 <trmi_>	i'll get back to you later, thanks a bunch for the info so far!
Apr 30 18:54:39 <kurahaupo>	See that's what I mean about rusty; I remembered that it was a special case but I didn't remember exactly what the interpretation was
Apr 30 18:59:05 <trmi_>	kurahaupo: this seems to be saying the same as you, https://github.com/jbruchon/elks/issues/597#issuecomment-620910495, though recommending VMIN 1 and VTIME 2
Apr 30 19:00:31 <kurahaupo>	trmi_:   If you want to be a bit smarter about extending reads that fill the buffer, you could restrict that to the case where the tail end of the buffer contains a partial escape sequence. If you know you have an ANSI terminal you could restrict that further: just do the partial blocking read for 2 bytes, and iff they're ESC+[ then loop in a blocking read for the finishing byte (which is any except \x20-\x3f)
Apr 30 19:01:27 <twkm>	"ansi" isn't all that terminals puke these days.
Apr 30 19:01:29 <trmi_>	yeah, i guess the longest escape sequence I care about is like 10 bytes
Apr 30 19:01:53 <twkm>	(even those days, but there was less)
Apr 30 19:03:25 <trmi_>	Also wondering if I can assume truecolor these days. I don't need to support everything, but "most". I have xterm256 color support, but kinda wanna remove, the whole list of terminals i've encountered have truecolor :D
Apr 30 19:03:26 <kurahaupo>	Reporting the current colour could be esc [ d : ddd : ddd : ddd : ddd x
Apr 30 19:03:54 <kurahaupo>	that's, um, 20 I think
Apr 30 19:04:00 <trmi_>	yeah, but I don't need that
Apr 30 19:04:18 <trmi_>	but I may encounter longer sequences than 10 I guess
Apr 30 19:04:25 *	jarthur_ is now known as jarthur
Apr 30 19:05:03 <kurahaupo>	trmi_: oh good you're on the right side of the netsplit
Apr 30 19:07:53 <Budd>	On the Pico, can I query the location of a PIO state machine's code (other than remembering where it's initially loaded)?
Apr 30 19:13:01 <twkm>	Budd: ##embedded is more likely to know.
Apr 30 19:13:48 <Budd>	thanks - I've been wondering if there was a better channel for pico questions.
Apr 30 19:14:42 <Budd>	(actually, just realized I posted this in the wrong channel to start... meant #raspberrypi)
Apr 30 19:48:49 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 19:48:49 2021

**** BEGIN LOGGING AT Fri Apr 30 19:49:14 2021

Apr 30 19:49:14 *	Now talking on ##C
Apr 30 19:49:14 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 30 19:49:14 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
Apr 30 19:49:15 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
Apr 30 19:49:15 *	Channel ##c url: http://www.iso-9899.info/
Apr 30 20:02:03 *	_d3x0r is now known as d3x0r
Apr 30 20:18:17 *	Gustavo6046 will set you to static and extern at the same time
Apr 30 20:18:18 <Gustavo6046>	>:D
Apr 30 20:53:41 <cahoots>	hi, i want to do the following: "char a[][2] = {{'0', '1'}}; char b[2] = a[0];", however for that second statement, it tells me "Array initializer must be an initializer list or string literal". any ideas how to do this?
Apr 30 20:57:08 <caze>	I don't think you can easily do what you're trying to do.
Apr 30 20:57:50 <fizzie>	You could write `char b[2] = {a[0][0], a[0][1]};`, potentially.
Apr 30 20:58:33 <fizzie>	Or `char *b = a[0];`, depending on circumstances.
Apr 30 20:58:37 <cahoots>	huh, interesting. so i can't just add a char[2] on the stack
Apr 30 20:58:57 <caze>	What?
Apr 30 20:59:12 <caze>	Your problem is with initializing the array the way you want to.
Apr 30 20:59:31 <caze>	The declaration is fine.
Apr 30 20:59:46 <cahoots>	kk ty
Apr 30 21:13:52 <mark4>	so i have an array of structures and im calculating the size with a macro but when i run the code the size is being calculated as zero
Apr 30 21:13:57 <mark4>	cant figure out what im doing wrong
Apr 30 21:14:16 <caze>	You're doing it wrong.
Apr 30 21:14:19 <mark4>	https://dpaste.com/GAMJVJVUC
Apr 30 21:14:34 <mark4>	line 348 VCOUNT is being set equal to zero
Apr 30 21:14:35 <mark4>	wtf
Apr 30 21:14:54 <mark4>	so the for loop on 357 is being optimized out
Apr 30 21:15:25 <mark4>	https://dpaste.com/7Z4K5C8BR
Apr 30 21:15:43 <mark4>	thats the definition for the elements of the array
Apr 30 21:15:43 <caze>	Don't you want to do s++ somewhere?
Apr 30 21:16:03 <mark4>	nopeoooh duh
Apr 30 21:16:19 <fizzie>	(Or just use array indexing.)
Apr 30 21:29:49 *	anton1 is now known as anton
Apr 30 21:51:35 <John_Ivan>	it is a pain in the ass to find serious people.
Apr 30 21:57:01 *	jarthur_ is now known as jarthur
Apr 30 22:24:20 *	Disconnected ()
**** ENDING LOGGING AT Fri Apr 30 22:24:20 2021

**** BEGIN LOGGING AT Sat May  1 03:56:57 2021

May 01 03:56:57 *	Now talking on ##C
May 01 03:56:57 *	Topic for ##C is: C Programming | PASTE (>3 lines): https://bpa.st/ | WIKI: http://www.iso-9899.info/ | BOOKS: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | the current standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
May 01 03:56:57 *	Topic for ##C set by dho!~dho@freenode/staff/dho (Fri Apr  9 04:35:19 2021)
May 01 03:56:58 -ChanServ-	[##c] Welcome to ##c! We engage in C programming discussions at all levels of expertise; don't hesitate to ask your question. If applicable, please prepare a testcase and paste it at http://ideone.com. We don't know about C++ (##c++) or C# (##csharp).
May 01 03:56:58 *	Channel ##c url: http://www.iso-9899.info/
May 01 05:21:37 <unixbsd>	hi
May 01 05:21:45 <pony>	hi
May 01 05:22:05 <unixbsd>	how to flush after a getchar() so that the next getchar() is not encoumbered by eventually (10) and skipped?
May 01 05:24:13 <wroathe>	10 is a line feed, and getchar wouldn't skip it
May 01 05:26:55 <unixbsd>	several getchar() will somehow arrive to one that is skipped soon or later
May 01 05:28:14 <wroathe>	unixbsd: Post your code in a paste
May 01 05:28:57 <unixbsd>	it will be very ugly.... you will cry a bit
May 01 05:31:15 <unixbsd>	Sorry... please find the getchar() failing... in ugly c code:  https://termbin.com/yc0d
May 01 05:42:23 <wroathe>	unixbsd: You're not even handling line feeds here. If a user types "y\n" into their terminal window stdin will then contain those two characters
May 01 05:42:44 <wroathe>	unixbsd: For example: https://godbolt.org/z/dxr3fnGav
May 01 05:43:08 <wroathe>	unixbsd: The input to that program is "a\n\n", as you can see in the upper right corner
May 01 05:53:18 <wroathe>	unixbsd: what you probably want to do is add a line like while (isspace(c = getchar())); to the start of your cpresskey routine, which will then cause it to skip through any whitespace characters in the input buffer
May 01 05:54:35 <wroathe>	unixbsd: Something like this: https://godbolt.org/z/KovGsEf4T
May 01 05:55:26 <Maxdamantus>	I'm guessing they want to read the input without waiting for the user to press enter, in which case you'll need to try to tell the terminal that you want that behavious.
May 01 05:56:08 <Maxdamantus>	you'd probably need to use tcsetattr to set the `IXON` iflag.
May 01 05:56:34 <Maxdamantus>	otherwise the terminal itself will buffer input until the user presses enter or ^d
May 01 05:58:13 <Maxdamantus>	(note that in that usual ~IXON mode, you can normally press backspace to delete characters that are still buffered by the terminal)
May 01 06:01:16 <Maxdamantus>	er, wait, ICANON, no IXON.
**** BEGIN LOGGING AT Sat Apr  1 00:57:31 2023

Apr 01 00:57:31 *	Now talking on ##C
Apr 01 00:57:31 *	Topic for ##C is: C Programming Community | Paste (>3 lines): https://bpa.st/ or http://ix.io/ | Wiki: http://www.iso-9899.info/ | Books: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | Standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 01 00:57:31 *	Topic for ##C set by tk (Wed Mar  8 20:51:23 2023)
Apr 01 11:37:24 *	Disconnected ()
**** ENDING LOGGING AT Sat Apr  1 11:37:24 2023

**** BEGIN LOGGING AT Sat Apr  1 11:37:47 2023

Apr 01 11:37:47 *	Now talking on ##C
Apr 01 11:37:47 *	Topic for ##C is: C Programming Community | Paste (>3 lines): https://bpa.st/ or http://ix.io/ | Wiki: http://www.iso-9899.info/ | Books: http://www.iso-9899.info/wiki/Books | C2X Charter: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm | Standard: http://iso-9899.info/wiki/The_Standard | Off-topic: ##c-offtopic
Apr 01 11:37:47 *	Topic for ##C set by tk (Wed Mar  8 20:51:23 2023)
